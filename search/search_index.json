{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"requests-connection-manager","text":"<p>A Python package that extends the popular <code>requests</code> library with advanced connection management features including connection pooling, automatic retries, rate limiting, and circuit breaker functionality.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Connection Pooling: Efficient HTTP connection reuse with urllib3</li> <li>Automatic Retries: Configurable retry logic with exponential backoff</li> <li>Rate Limiting: Built-in request throttling to prevent API abuse</li> <li>Circuit Breaker: Fail-fast pattern for handling service failures</li> <li>Thread Safety: Safe for use in multi-threaded applications</li> <li>Drop-in Replacement: Works as an enhanced replacement for requests.Session</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\n# Create a connection manager with enhanced features\nmanager = ConnectionManager(\n    max_retries=3,\n    timeout=30,\n    rate_limit_requests=100,\n    rate_limit_period=60\n)\n\n# Use like requests.Session\nresponse = manager.get('https://api.example.com/data')\nprint(response.json())\n\n# Context manager support\nwith ConnectionManager() as manager:\n    response = manager.post('https://api.example.com/users', json={'name': 'John'})\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install requests-connection-manager\n</code></pre>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Installation Guide</li> <li>Quick Start Guide</li> <li>API Reference</li> <li>Examples</li> <li>Contributing</li> </ul>"},{"location":"advanced-features/","title":"Advanced Features","text":"<p>This guide covers the advanced capabilities of <code>requests-connection-manager</code> for power users and complex scenarios.</p>"},{"location":"advanced-features/#plugin-system","title":"Plugin System","text":"<p>The plugin system allows you to extend functionality with custom hooks that execute at different stages of the request lifecycle.</p>"},{"location":"advanced-features/#hook-types","title":"Hook Types","text":"<ul> <li>Pre-Request Hooks: Execute before sending requests</li> <li>Post-Response Hooks: Execute after receiving responses  </li> <li>Error Hooks: Execute when errors occur</li> </ul>"},{"location":"advanced-features/#creating-custom-plugins","title":"Creating Custom Plugins","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\ndef add_request_id_hook(request_context):\n    \"\"\"Add unique request ID to all requests.\"\"\"\n    import uuid\n    if 'headers' not in request_context.kwargs:\n        request_context.kwargs['headers'] = {}\n    request_context.kwargs['headers']['X-Request-ID'] = str(uuid.uuid4())\n\ndef log_response_time_hook(response_context):\n    \"\"\"Log response times for monitoring.\"\"\"\n    duration = response_context.response.elapsed.total_seconds()\n    url = response_context.request_context.url\n    print(f\"Request to {url} took {duration:.3f}s\")\n\ndef retry_on_rate_limit_hook(error_context):\n    \"\"\"Custom retry logic for rate limits.\"\"\"\n    if hasattr(error_context.exception, 'response'):\n        if error_context.exception.response.status_code == 429:\n            # Extract retry-after header and implement custom backoff\n            retry_after = error_context.exception.response.headers.get('Retry-After')\n            if retry_after:\n                import time\n                time.sleep(int(retry_after))\n                # Mark as handled to trigger retry\n                error_context.handled = True\n\n# Register hooks\nmanager = ConnectionManager()\nmanager.register_pre_request_hook(add_request_id_hook)\nmanager.register_post_response_hook(log_response_time_hook)\nmanager.register_error_hook(retry_on_rate_limit_hook)\n</code></pre>"},{"location":"advanced-features/#advanced-plugin-example-request-caching","title":"Advanced Plugin Example: Request Caching","text":"<pre><code>import hashlib\nimport json\nimport time\nfrom typing import Dict, Any\n\nclass RequestCache:\n    def __init__(self, ttl: int = 300):  # 5 minutes default TTL\n        self.cache: Dict[str, Dict[str, Any]] = {}\n        self.ttl = ttl\n\n    def _get_cache_key(self, request_context):\n        \"\"\"Generate cache key from request details.\"\"\"\n        key_data = {\n            'method': request_context.method,\n            'url': request_context.url,\n            'headers': request_context.kwargs.get('headers', {}),\n            'params': request_context.kwargs.get('params', {}),\n            'data': request_context.kwargs.get('data', ''),\n            'json': request_context.kwargs.get('json', {})\n        }\n        key_str = json.dumps(key_data, sort_keys=True)\n        return hashlib.md5(key_str.encode()).hexdigest()\n\n    def pre_request_hook(self, request_context):\n        \"\"\"Check cache before making request.\"\"\"\n        # Only cache GET requests\n        if request_context.method.upper() != 'GET':\n            return\n\n        cache_key = self._get_cache_key(request_context)\n\n        if cache_key in self.cache:\n            cached_data = self.cache[cache_key]\n\n            # Check if cache entry is still valid\n            if time.time() - cached_data['timestamp'] &lt; self.ttl:\n                # Create a mock response from cached data\n                import requests\n                response = requests.Response()\n                response._content = cached_data['content']\n                response.status_code = cached_data['status_code']\n                response.headers.update(cached_data['headers'])\n\n                # Store in request context to use in post_response\n                request_context._cached_response = response\n                print(f\"Cache HIT for {request_context.url}\")\n                return\n\n        print(f\"Cache MISS for {request_context.url}\")\n\n    def post_response_hook(self, response_context):\n        \"\"\"Cache successful responses.\"\"\"\n        request_context = response_context.request_context\n\n        # Use cached response if available\n        if hasattr(request_context, '_cached_response'):\n            response_context.response = request_context._cached_response\n            return\n\n        # Only cache GET requests with successful responses\n        if (request_context.method.upper() == 'GET' and \n            200 &lt;= response_context.response.status_code &lt; 300):\n\n            cache_key = self._get_cache_key(request_context)\n\n            self.cache[cache_key] = {\n                'content': response_context.response.content,\n                'status_code': response_context.response.status_code,\n                'headers': dict(response_context.response.headers),\n                'timestamp': time.time()\n            }\n\n    def clear_cache(self):\n        \"\"\"Clear all cached responses.\"\"\"\n        self.cache.clear()\n\n# Usage\ncache = RequestCache(ttl=600)  # 10 minutes\nmanager = ConnectionManager()\n\nmanager.register_pre_request_hook(cache.pre_request_hook)\nmanager.register_post_response_hook(cache.post_response_hook)\n\nwith manager:\n    # First request - cache miss\n    response1 = manager.get('https://httpbin.org/get?param=value')\n\n    # Second request - cache hit\n    response2 = manager.get('https://httpbin.org/get?param=value')\n</code></pre>"},{"location":"advanced-features/#ssltls-advanced-configuration","title":"SSL/TLS Advanced Configuration","text":""},{"location":"advanced-features/#custom-ssl-context","title":"Custom SSL Context","text":"<pre><code>import ssl\nfrom requests_connection_manager import ConnectionManager\n\n# Create advanced SSL context\nssl_context = ssl.create_default_context()\n\n# Configure specific TLS version\nssl_context.minimum_version = ssl.TLSVersion.TLSv1_2\nssl_context.maximum_version = ssl.TLSVersion.TLSv1_3\n\n# Configure cipher suites\nssl_context.set_ciphers('ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS')\n\n# Configure certificate verification\nssl_context.check_hostname = True\nssl_context.verify_mode = ssl.CERT_REQUIRED\n\n# Load custom CA certificates\nssl_context.load_verify_locations('/path/to/custom-ca-bundle.pem')\n\n# Use with connection manager\nmanager = ConnectionManager(ssl_context=ssl_context)\n</code></pre>"},{"location":"advanced-features/#mutual-tls-mtls-configuration","title":"Mutual TLS (mTLS) Configuration","text":"<pre><code># Client certificate authentication\nmanager = ConnectionManager(\n    cert=('/path/to/client.crt', '/path/to/client.key'),\n    verify='/path/to/ca-bundle.pem'\n)\n\n# Or with password-protected key\ncert_config = ('/path/to/client.crt', '/path/to/client.key', 'key-password')\nmanager = ConnectionManager(cert=cert_config)\n\nwith manager:\n    # All requests use client certificate\n    response = manager.get('https://secure-api.example.com/data')\n</code></pre>"},{"location":"advanced-features/#ssl-pinning","title":"SSL Pinning","text":"<pre><code>import ssl\nimport hashlib\nfrom requests_connection_manager import ConnectionManager\n\nclass SSLPinningManager(ConnectionManager):\n    def __init__(self, expected_cert_hash: str, **kwargs):\n        super().__init__(**kwargs)\n        self.expected_cert_hash = expected_cert_hash\n        self.register_pre_request_hook(self._validate_certificate)\n\n    def _validate_certificate(self, request_context):\n        \"\"\"Validate certificate hash matches expected value.\"\"\"\n        # This is a simplified example - real implementation would\n        # need to intercept the SSL handshake\n        pass\n\n# Usage with expected certificate hash\nmanager = SSLPinningManager(\n    expected_cert_hash=\"sha256:ABC123...\",\n    verify=True\n)\n</code></pre>"},{"location":"advanced-features/#advanced-circuit-breaker-patterns","title":"Advanced Circuit Breaker Patterns","text":""},{"location":"advanced-features/#custom-circuit-breaker-states","title":"Custom Circuit Breaker States","text":"<pre><code>import pybreaker\nfrom requests_connection_manager import ConnectionManager\n\nclass AdvancedCircuitBreaker:\n    def __init__(self):\n        # Create circuit breaker with custom state monitoring\n        self.circuit_breaker = pybreaker.CircuitBreaker(\n            fail_max=5,\n            reset_timeout=60,\n            exclude=[Exception]  # Custom exclusion logic\n        )\n\n        # Track state changes\n        self.circuit_breaker.add_listener(self._on_state_change)\n\n    def _on_state_change(self, old_state, new_state, exception=None):\n        \"\"\"Handle circuit breaker state changes.\"\"\"\n        print(f\"Circuit breaker state changed: {old_state} -&gt; {new_state}\")\n\n        if new_state == pybreaker.CircuitBreakerState.OPEN:\n            # Alert monitoring system\n            self._send_alert(\"Circuit breaker opened\", exception)\n        elif new_state == pybreaker.CircuitBreakerState.CLOSED:\n            # Recovery notification\n            self._send_notification(\"Service recovered\")\n\n    def _send_alert(self, message, exception):\n        \"\"\"Send alert to monitoring system.\"\"\"\n        print(f\"ALERT: {message} - {exception}\")\n\n    def _send_notification(self, message):\n        \"\"\"Send notification about recovery.\"\"\"\n        print(f\"INFO: {message}\")\n\n# Create manager with advanced circuit breaker\nbreaker = AdvancedCircuitBreaker()\nmanager = ConnectionManager()\n\n# Replace default circuit breaker\nmanager.circuit_breaker = breaker.circuit_breaker\n</code></pre>"},{"location":"advanced-features/#circuit-breaker-with-fallback","title":"Circuit Breaker with Fallback","text":"<pre><code>def create_fallback_manager():\n    \"\"\"Create manager with fallback service configuration.\"\"\"\n\n    primary_config = {\n        'api.primary.com': {\n            'circuit_breaker_failure_threshold': 3,\n            'circuit_breaker_recovery_timeout': 30,\n            'timeout': 10\n        }\n    }\n\n    fallback_config = {\n        'api.fallback.com': {\n            'circuit_breaker_failure_threshold': 10,  # More tolerant\n            'circuit_breaker_recovery_timeout': 60,\n            'timeout': 20\n        }\n    }\n\n    return ConnectionManager(endpoint_configs={**primary_config, **fallback_config})\n\ndef fetch_with_fallback(resource_path):\n    \"\"\"Fetch data with automatic fallback.\"\"\"\n    manager = create_fallback_manager()\n\n    with manager:\n        try:\n            # Try primary service\n            response = manager.get(f'https://api.primary.com{resource_path}')\n            return response.json()\n\n        except Exception as e:\n            print(f\"Primary service failed: {e}\")\n\n            try:\n                # Try fallback service\n                response = manager.get(f'https://api.fallback.com{resource_path}')\n                return response.json()\n\n            except Exception as fallback_error:\n                print(f\"Fallback service also failed: {fallback_error}\")\n                return None\n</code></pre>"},{"location":"advanced-features/#advanced-rate-limiting","title":"Advanced Rate Limiting","text":""},{"location":"advanced-features/#adaptive-rate-limiting","title":"Adaptive Rate Limiting","text":"<pre><code>import time\nfrom typing import Dict\nfrom requests_connection_manager import ConnectionManager\n\nclass AdaptiveRateLimiter:\n    def __init__(self):\n        self.response_times: Dict[str, list] = {}\n        self.rate_limits: Dict[str, int] = {}\n        self.base_rate_limit = 100\n\n    def pre_request_hook(self, request_context):\n        \"\"\"Adjust rate limit based on response times.\"\"\"\n        url_pattern = self._get_url_pattern(request_context.url)\n\n        if url_pattern in self.response_times:\n            avg_response_time = sum(self.response_times[url_pattern]) / len(self.response_times[url_pattern])\n\n            # Reduce rate limit if responses are slow\n            if avg_response_time &gt; 2.0:  # 2 seconds\n                new_rate = max(10, self.base_rate_limit // 2)\n            elif avg_response_time &gt; 1.0:  # 1 second\n                new_rate = max(20, self.base_rate_limit // 1.5)\n            else:\n                new_rate = self.base_rate_limit\n\n            self.rate_limits[url_pattern] = new_rate\n\n        request_context.start_time = time.time()\n\n    def post_response_hook(self, response_context):\n        \"\"\"Track response times for adaptation.\"\"\"\n        url_pattern = self._get_url_pattern(response_context.request_context.url)\n        response_time = time.time() - response_context.request_context.start_time\n\n        if url_pattern not in self.response_times:\n            self.response_times[url_pattern] = []\n\n        self.response_times[url_pattern].append(response_time)\n\n        # Keep only recent measurements\n        if len(self.response_times[url_pattern]) &gt; 10:\n            self.response_times[url_pattern] = self.response_times[url_pattern][-10:]\n\n    def _get_url_pattern(self, url):\n        \"\"\"Extract URL pattern for grouping.\"\"\"\n        from urllib.parse import urlparse\n        parsed = urlparse(url)\n        return f\"{parsed.scheme}://{parsed.netloc}\"\n\n# Usage\nadaptive_limiter = AdaptiveRateLimiter()\nmanager = ConnectionManager()\n\nmanager.register_pre_request_hook(adaptive_limiter.pre_request_hook)\nmanager.register_post_response_hook(adaptive_limiter.post_response_hook)\n</code></pre>"},{"location":"advanced-features/#per-user-rate-limiting","title":"Per-User Rate Limiting","text":"<pre><code>import time\nfrom collections import defaultdict\nfrom threading import Lock\n\nclass PerUserRateLimiter:\n    def __init__(self, requests_per_minute: int = 60):\n        self.requests_per_minute = requests_per_minute\n        self.user_requests: Dict[str, list] = defaultdict(list)\n        self.lock = Lock()\n\n    def pre_request_hook(self, request_context):\n        \"\"\"Check rate limit per user.\"\"\"\n        # Extract user ID from headers or URL\n        user_id = self._extract_user_id(request_context)\n\n        if user_id:\n            with self.lock:\n                current_time = time.time()\n                user_requests = self.user_requests[user_id]\n\n                # Remove requests older than 1 minute\n                cutoff_time = current_time - 60\n                user_requests[:] = [req_time for req_time in user_requests if req_time &gt; cutoff_time]\n\n                # Check if user has exceeded rate limit\n                if len(user_requests) &gt;= self.requests_per_minute:\n                    from requests_connection_manager.exceptions import RateLimitExceeded\n                    raise RateLimitExceeded(f\"Rate limit exceeded for user {user_id}\")\n\n                # Add current request\n                user_requests.append(current_time)\n\n    def _extract_user_id(self, request_context):\n        \"\"\"Extract user ID from request context.\"\"\"\n        headers = request_context.kwargs.get('headers', {})\n\n        # Check for user ID in headers\n        return headers.get('X-User-ID') or headers.get('User-ID')\n\n# Usage\nuser_limiter = PerUserRateLimiter(requests_per_minute=30)\nmanager = ConnectionManager()\nmanager.register_pre_request_hook(user_limiter.pre_request_hook)\n</code></pre>"},{"location":"advanced-features/#advanced-monitoring-and-observability","title":"Advanced Monitoring and Observability","text":""},{"location":"advanced-features/#distributed-tracing-integration","title":"Distributed Tracing Integration","text":"<pre><code>import uuid\nimport time\nfrom typing import Optional\n\nclass DistributedTracing:\n    def __init__(self, service_name: str):\n        self.service_name = service_name\n        self.active_traces = {}\n\n    def pre_request_hook(self, request_context):\n        \"\"\"Start distributed trace.\"\"\"\n        trace_id = str(uuid.uuid4())\n        span_id = str(uuid.uuid4())\n\n        # Add tracing headers\n        if 'headers' not in request_context.kwargs:\n            request_context.kwargs['headers'] = {}\n\n        request_context.kwargs['headers'].update({\n            'X-Trace-ID': trace_id,\n            'X-Span-ID': span_id,\n            'X-Parent-Span': getattr(request_context, 'parent_span', ''),\n            'X-Service-Name': self.service_name\n        })\n\n        # Store trace information\n        request_context.trace_id = trace_id\n        request_context.span_id = span_id\n        request_context.start_time = time.time()\n\n        self.active_traces[span_id] = {\n            'trace_id': trace_id,\n            'span_id': span_id,\n            'method': request_context.method,\n            'url': request_context.url,\n            'start_time': request_context.start_time\n        }\n\n    def post_response_hook(self, response_context):\n        \"\"\"Complete distributed trace.\"\"\"\n        request_context = response_context.request_context\n\n        if hasattr(request_context, 'span_id'):\n            span_id = request_context.span_id\n\n            if span_id in self.active_traces:\n                trace_data = self.active_traces[span_id]\n                trace_data.update({\n                    'duration': time.time() - request_context.start_time,\n                    'status_code': response_context.response.status_code,\n                    'success': 200 &lt;= response_context.response.status_code &lt; 400\n                })\n\n                # Send to tracing backend (Jaeger, Zipkin, etc.)\n                self._send_trace(trace_data)\n                del self.active_traces[span_id]\n\n    def error_hook(self, error_context):\n        \"\"\"Handle trace for errors.\"\"\"\n        request_context = error_context.request_context\n\n        if hasattr(request_context, 'span_id'):\n            span_id = request_context.span_id\n\n            if span_id in self.active_traces:\n                trace_data = self.active_traces[span_id]\n                trace_data.update({\n                    'duration': time.time() - request_context.start_time,\n                    'error': str(error_context.exception),\n                    'success': False\n                })\n\n                self._send_trace(trace_data)\n                del self.active_traces[span_id]\n\n    def _send_trace(self, trace_data):\n        \"\"\"Send trace data to monitoring backend.\"\"\"\n        # In real implementation, send to Jaeger, Zipkin, or other tracing system\n        print(f\"Trace: {trace_data['trace_id']} - {trace_data['method']} {trace_data['url']} - \"\n              f\"{trace_data['duration']:.3f}s - Success: {trace_data.get('success', False)}\")\n\n# Usage\ntracer = DistributedTracing(\"my-service\")\nmanager = ConnectionManager()\n\nmanager.register_pre_request_hook(tracer.pre_request_hook)\nmanager.register_post_response_hook(tracer.post_response_hook)\nmanager.register_error_hook(tracer.error_hook)\n</code></pre>"},{"location":"advanced-features/#performance-metrics-collection","title":"Performance Metrics Collection","text":"<pre><code>import time\nimport statistics\nfrom collections import defaultdict\nfrom threading import Lock\n\nclass PerformanceMonitor:\n    def __init__(self):\n        self.metrics = defaultdict(lambda: {\n            'request_count': 0,\n            'error_count': 0,\n            'response_times': [],\n            'status_codes': defaultdict(int)\n        })\n        self.lock = Lock()\n\n    def pre_request_hook(self, request_context):\n        \"\"\"Mark request start time.\"\"\"\n        request_context.perf_start_time = time.perf_counter()\n\n    def post_response_hook(self, response_context):\n        \"\"\"Collect performance metrics.\"\"\"\n        request_context = response_context.request_context\n\n        if hasattr(request_context, 'perf_start_time'):\n            duration = time.perf_counter() - request_context.perf_start_time\n\n            # Extract service name from URL\n            service_name = self._extract_service_name(request_context.url)\n\n            with self.lock:\n                metrics = self.metrics[service_name]\n                metrics['request_count'] += 1\n                metrics['response_times'].append(duration)\n                metrics['status_codes'][response_context.response.status_code] += 1\n\n                # Keep only recent response times (last 1000 requests)\n                if len(metrics['response_times']) &gt; 1000:\n                    metrics['response_times'] = metrics['response_times'][-1000:]\n\n    def error_hook(self, error_context):\n        \"\"\"Track errors.\"\"\"\n        service_name = self._extract_service_name(error_context.request_context.url)\n\n        with self.lock:\n            self.metrics[service_name]['error_count'] += 1\n\n    def _extract_service_name(self, url):\n        \"\"\"Extract service name from URL.\"\"\"\n        from urllib.parse import urlparse\n        parsed = urlparse(url)\n        return parsed.netloc\n\n    def get_metrics_summary(self):\n        \"\"\"Get performance metrics summary.\"\"\"\n        summary = {}\n\n        with self.lock:\n            for service, metrics in self.metrics.items():\n                response_times = metrics['response_times']\n\n                if response_times:\n                    summary[service] = {\n                        'request_count': metrics['request_count'],\n                        'error_count': metrics['error_count'],\n                        'error_rate': metrics['error_count'] / metrics['request_count'],\n                        'avg_response_time': statistics.mean(response_times),\n                        'p95_response_time': statistics.quantiles(response_times, n=20)[18] if len(response_times) &gt; 20 else max(response_times),\n                        'p99_response_time': statistics.quantiles(response_times, n=100)[98] if len(response_times) &gt; 100 else max(response_times),\n                        'status_codes': dict(metrics['status_codes'])\n                    }\n\n        return summary\n\n# Usage\nmonitor = PerformanceMonitor()\nmanager = ConnectionManager()\n\nmanager.register_pre_request_hook(monitor.pre_request_hook)\nmanager.register_post_response_hook(monitor.post_response_hook)\nmanager.register_error_hook(monitor.error_hook)\n\nwith manager:\n    # Make some requests\n    for i in range(10):\n        manager.get(f'https://httpbin.org/delay/{i%3}')\n\n# Get performance summary\nprint(monitor.get_metrics_summary())\n</code></pre>"},{"location":"advanced-features/#load-balancing-and-service-discovery","title":"Load Balancing and Service Discovery","text":""},{"location":"advanced-features/#round-robin-load-balancer","title":"Round-Robin Load Balancer","text":"<pre><code>import itertools\nfrom typing import List\nfrom requests_connection_manager import ConnectionManager\n\nclass LoadBalancedManager:\n    def __init__(self, service_endpoints: List[str], **kwargs):\n        self.endpoints = itertools.cycle(service_endpoints)\n        self.base_manager = ConnectionManager(**kwargs)\n\n    def _get_next_endpoint(self):\n        \"\"\"Get next endpoint in round-robin fashion.\"\"\"\n        return next(self.endpoints)\n\n    def request(self, method: str, path: str, **kwargs):\n        \"\"\"Make request to next available endpoint.\"\"\"\n        endpoint = self._get_next_endpoint()\n        url = f\"{endpoint.rstrip('/')}/{path.lstrip('/')}\"\n\n        return self.base_manager.request(method, url, **kwargs)\n\n    def get(self, path: str, **kwargs):\n        return self.request('GET', path, **kwargs)\n\n    def post(self, path: str, **kwargs):\n        return self.request('POST', path, **kwargs)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.base_manager.close()\n\n# Usage\nendpoints = [\n    'https://api1.example.com',\n    'https://api2.example.com',\n    'https://api3.example.com'\n]\n\nwith LoadBalancedManager(endpoints) as lb_manager:\n    # Requests are distributed across endpoints\n    for i in range(6):\n        response = lb_manager.get(f'/data/{i}')\n        print(f\"Request {i}: {response.status_code}\")\n</code></pre>"},{"location":"advanced-features/#health-aware-load-balancer","title":"Health-Aware Load Balancer","text":"<pre><code>import time\nimport random\nfrom typing import List, Dict\nfrom threading import Lock\n\nclass HealthAwareLoadBalancer:\n    def __init__(self, service_endpoints: List[str], health_check_interval: int = 30):\n        self.endpoints = service_endpoints\n        self.healthy_endpoints = set(service_endpoints)\n        self.endpoint_health = {ep: True for ep in service_endpoints}\n        self.last_health_check = 0\n        self.health_check_interval = health_check_interval\n        self.lock = Lock()\n        self.manager = ConnectionManager(timeout=5)\n\n    def _check_endpoint_health(self, endpoint: str) -&gt; bool:\n        \"\"\"Check if endpoint is healthy.\"\"\"\n        try:\n            response = self.manager.get(f\"{endpoint}/health\", timeout=5)\n            return response.status_code == 200\n        except Exception:\n            return False\n\n    def _update_health_status(self):\n        \"\"\"Update health status of all endpoints.\"\"\"\n        current_time = time.time()\n\n        if current_time - self.last_health_check &lt; self.health_check_interval:\n            return\n\n        with self.lock:\n            for endpoint in self.endpoints:\n                is_healthy = self._check_endpoint_health(endpoint)\n                self.endpoint_health[endpoint] = is_healthy\n\n                if is_healthy:\n                    self.healthy_endpoints.add(endpoint)\n                else:\n                    self.healthy_endpoints.discard(endpoint)\n\n            self.last_health_check = current_time\n\n    def get_healthy_endpoint(self) -&gt; str:\n        \"\"\"Get a healthy endpoint.\"\"\"\n        self._update_health_status()\n\n        with self.lock:\n            if not self.healthy_endpoints:\n                # If no healthy endpoints, try any endpoint\n                return random.choice(self.endpoints)\n\n            return random.choice(list(self.healthy_endpoints))\n\n    def request(self, method: str, path: str, **kwargs):\n        \"\"\"Make request to a healthy endpoint.\"\"\"\n        endpoint = self.get_healthy_endpoint()\n        url = f\"{endpoint.rstrip('/')}/{path.lstrip('/')}\"\n\n        try:\n            return self.manager.request(method, url, **kwargs)\n        except Exception as e:\n            # Mark endpoint as unhealthy on error\n            with self.lock:\n                self.healthy_endpoints.discard(endpoint)\n                self.endpoint_health[endpoint] = False\n            raise\n\n# Usage\nendpoints = [\n    'https://api1.example.com',\n    'https://api2.example.com',\n    'https://api3.example.com'\n]\n\nlb = HealthAwareLoadBalancer(endpoints)\nresponse = lb.request('GET', '/data')\n</code></pre>"},{"location":"advanced-features/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Usage Examples - More practical examples</li> <li>Configuration - Detailed configuration options</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for <code>requests-connection-manager</code>.</p>"},{"location":"api-reference/#connectionmanager","title":"ConnectionManager","text":"<p>Main class for synchronous HTTP requests with enhanced features.</p>"},{"location":"api-reference/#constructor","title":"Constructor","text":"<pre><code>ConnectionManager(\n    pool_connections: int = 10,\n    pool_maxsize: int = 10,\n    max_retries: int = 3,\n    backoff_factor: float = 0.3,\n    rate_limit_requests: int = 100,\n    rate_limit_period: int = 60,\n    circuit_breaker_failure_threshold: int = 5,\n    circuit_breaker_recovery_timeout: float = 60,\n    timeout: int = 30,\n    endpoint_configs: Optional[Dict[str, Dict[str, Any]]] = None,\n    api_key: Optional[str] = None,\n    api_key_header: str = \"X-API-Key\",\n    bearer_token: Optional[str] = None,\n    oauth2_token: Optional[str] = None,\n    basic_auth: Optional[tuple] = None,\n    verify: Union[bool, str] = True,\n    cert: Optional[Union[str, tuple]] = None,\n    connect_timeout: Optional[float] = None,\n    read_timeout: Optional[float] = None,\n    ssl_context: Optional[Any] = None\n)\n</code></pre>"},{"location":"api-reference/#parameters","title":"Parameters","text":"<ul> <li>pool_connections (int): Number of connection pools to cache. Default: 10</li> <li>pool_maxsize (int): Maximum number of connections in each pool. Default: 10</li> <li>max_retries (int): Maximum number of retry attempts. Default: 3</li> <li>backoff_factor (float): Exponential backoff multiplier for retries. Default: 0.3</li> <li>rate_limit_requests (int): Number of requests allowed per period. Default: 100</li> <li>rate_limit_period (int): Time period for rate limiting in seconds. Default: 60</li> <li>circuit_breaker_failure_threshold (int): Number of failures before opening circuit breaker. Default: 5</li> <li>circuit_breaker_recovery_timeout (float): Recovery timeout for circuit breaker in seconds. Default: 60</li> <li>timeout (int): Default request timeout in seconds. Default: 30</li> <li>endpoint_configs (Dict): Endpoint-specific configuration overrides</li> <li>api_key (str): Global API key for authentication</li> <li>api_key_header (str): Header name for API key. Default: \"X-API-Key\"</li> <li>bearer_token (str): Global Bearer token for authentication</li> <li>oauth2_token (str): Global OAuth2 token for authentication</li> <li>basic_auth (tuple): Tuple of (username, password) for basic authentication</li> <li>verify (bool|str): SSL certificate verification. True, False, or path to CA bundle</li> <li>cert (str|tuple): Client certificate file path or (cert_file, key_file) tuple</li> <li>connect_timeout (float): Connection timeout in seconds</li> <li>read_timeout (float): Read timeout in seconds</li> <li>ssl_context: Custom SSL context for advanced SSL configuration</li> </ul>"},{"location":"api-reference/#http-methods","title":"HTTP Methods","text":""},{"location":"api-reference/#request","title":"request()","text":"<pre><code>request(method: str, url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make HTTP request with all enhancements.</p> <p>Parameters: - method (str): HTTP method (GET, POST, etc.) - url (str): Request URL - kwargs: Additional request parameters</p> <p>Returns: <code>requests.Response</code> object</p> <p>Raises: - <code>RateLimitExceeded</code>: When rate limit is exceeded - <code>CircuitBreakerOpen</code>: When circuit breaker is open - <code>MaxRetriesExceeded</code>: When maximum retries are exceeded</p>"},{"location":"api-reference/#get","title":"get()","text":"<pre><code>get(url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make GET request.</p>"},{"location":"api-reference/#post","title":"post()","text":"<pre><code>post(url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make POST request.</p>"},{"location":"api-reference/#put","title":"put()","text":"<pre><code>put(url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make PUT request.</p>"},{"location":"api-reference/#delete","title":"delete()","text":"<pre><code>delete(url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make DELETE request.</p>"},{"location":"api-reference/#patch","title":"patch()","text":"<pre><code>patch(url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make PATCH request.</p>"},{"location":"api-reference/#head","title":"head()","text":"<pre><code>head(url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make HEAD request.</p>"},{"location":"api-reference/#options","title":"options()","text":"<pre><code>options(url: str, **kwargs) -&gt; requests.Response\n</code></pre> <p>Make OPTIONS request.</p>"},{"location":"api-reference/#batch-operations","title":"Batch Operations","text":""},{"location":"api-reference/#batch_request","title":"batch_request()","text":"<pre><code>batch_request(\n    requests_data: List[Tuple[str, str, Dict[str, Any]]], \n    max_workers: int = 5,\n    return_exceptions: bool = True\n) -&gt; List[Union[requests.Response, Exception]]\n</code></pre> <p>Perform multiple HTTP requests concurrently.</p> <p>Parameters: - requests_data: List of (method, url, kwargs) tuples - max_workers: Maximum number of concurrent requests - return_exceptions: If True, exceptions are returned instead of raised</p> <p>Returns: List of Response objects or exceptions</p>"},{"location":"api-reference/#configuration-management","title":"Configuration Management","text":""},{"location":"api-reference/#add_endpoint_config","title":"add_endpoint_config()","text":"<pre><code>add_endpoint_config(pattern: str, config: Dict[str, Any]) -&gt; None\n</code></pre> <p>Add configuration for specific endpoint pattern.</p>"},{"location":"api-reference/#remove_endpoint_config","title":"remove_endpoint_config()","text":"<pre><code>remove_endpoint_config(pattern: str) -&gt; None\n</code></pre> <p>Remove configuration for endpoint pattern.</p>"},{"location":"api-reference/#get_endpoint_configs","title":"get_endpoint_configs()","text":"<pre><code>get_endpoint_configs() -&gt; Dict[str, Dict[str, Any]]\n</code></pre> <p>Get all endpoint configurations.</p>"},{"location":"api-reference/#authentication-methods","title":"Authentication Methods","text":""},{"location":"api-reference/#set_api_key","title":"set_api_key()","text":"<pre><code>set_api_key(api_key: str, header_name: str = \"X-API-Key\") -&gt; None\n</code></pre> <p>Set global API key authentication.</p>"},{"location":"api-reference/#set_bearer_token","title":"set_bearer_token()","text":"<pre><code>set_bearer_token(token: str) -&gt; None\n</code></pre> <p>Set global Bearer token authentication.</p>"},{"location":"api-reference/#set_oauth2_token","title":"set_oauth2_token()","text":"<pre><code>set_oauth2_token(token: str) -&gt; None\n</code></pre> <p>Set global OAuth2 token authentication.</p>"},{"location":"api-reference/#set_basic_auth","title":"set_basic_auth()","text":"<pre><code>set_basic_auth(username: str, password: str) -&gt; None\n</code></pre> <p>Set global basic authentication.</p>"},{"location":"api-reference/#set_endpoint_auth","title":"set_endpoint_auth()","text":"<pre><code>set_endpoint_auth(pattern: str, auth_type: str, **auth_kwargs) -&gt; None\n</code></pre> <p>Set authentication for specific endpoint pattern.</p> <p>Parameters: - pattern: URL pattern to match - auth_type: Type of authentication ('api_key', 'bearer', 'oauth2', 'basic') - auth_kwargs: Authentication parameters</p>"},{"location":"api-reference/#clear_auth","title":"clear_auth()","text":"<pre><code>clear_auth(pattern: Optional[str] = None) -&gt; None\n</code></pre> <p>Clear authentication for endpoint or globally.</p>"},{"location":"api-reference/#ssl-configuration","title":"SSL Configuration","text":""},{"location":"api-reference/#set_ssl_verification","title":"set_ssl_verification()","text":"<pre><code>set_ssl_verification(verify: Union[bool, str]) -&gt; None\n</code></pre> <p>Set SSL certificate verification.</p>"},{"location":"api-reference/#set_client_certificate","title":"set_client_certificate()","text":"<pre><code>set_client_certificate(cert: Union[str, tuple]) -&gt; None\n</code></pre> <p>Set client certificate for mutual TLS.</p>"},{"location":"api-reference/#set_timeouts","title":"set_timeouts()","text":"<pre><code>set_timeouts(connect_timeout: Optional[float] = None, read_timeout: Optional[float] = None) -&gt; None\n</code></pre> <p>Set fine-grained connection and read timeouts.</p>"},{"location":"api-reference/#set_ssl_context","title":"set_ssl_context()","text":"<pre><code>set_ssl_context(ssl_context: Any) -&gt; None\n</code></pre> <p>Set custom SSL context.</p>"},{"location":"api-reference/#plugin-system","title":"Plugin System","text":""},{"location":"api-reference/#register_pre_request_hook","title":"register_pre_request_hook()","text":"<pre><code>register_pre_request_hook(hook_func: Callable[[RequestContext], None]) -&gt; None\n</code></pre> <p>Register pre-request hook.</p>"},{"location":"api-reference/#register_post_response_hook","title":"register_post_response_hook()","text":"<pre><code>register_post_response_hook(hook_func: Callable[[ResponseContext], None]) -&gt; None\n</code></pre> <p>Register post-response hook.</p>"},{"location":"api-reference/#register_error_hook","title":"register_error_hook()","text":"<pre><code>register_error_hook(hook_func: Callable[[ErrorContext], None]) -&gt; None\n</code></pre> <p>Register error handling hook.</p>"},{"location":"api-reference/#unregister_hook","title":"unregister_hook()","text":"<pre><code>unregister_hook(hook_type: HookType, hook_func: Callable) -&gt; None\n</code></pre> <p>Unregister specific hook.</p>"},{"location":"api-reference/#list_hooks","title":"list_hooks()","text":"<pre><code>list_hooks() -&gt; Dict[str, List[str]]\n</code></pre> <p>List all registered hooks.</p>"},{"location":"api-reference/#monitoring","title":"Monitoring","text":""},{"location":"api-reference/#get_stats","title":"get_stats()","text":"<pre><code>get_stats() -&gt; Dict[str, Any]\n</code></pre> <p>Get current statistics about the connection manager.</p> <p>Returns: Dictionary with current stats including: - <code>circuit_breaker_state</code>: Current circuit breaker state - <code>circuit_breaker_failure_count</code>: Number of failures - <code>rate_limit_requests</code>: Current rate limit - <code>timeout</code>: Current timeout setting - <code>registered_hooks</code>: List of registered hooks - <code>endpoint_configs</code>: Endpoint configurations</p>"},{"location":"api-reference/#context-manager","title":"Context Manager","text":""},{"location":"api-reference/#__enter__-__exit__","title":"__enter__() / __exit__()","text":"<pre><code>with ConnectionManager() as manager:\n    # Use manager\n    pass\n# Automatically cleaned up\n</code></pre>"},{"location":"api-reference/#close","title":"close()","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Manually close session and clean up resources.</p>"},{"location":"api-reference/#asyncconnectionmanager","title":"AsyncConnectionManager","text":"<p>Async version of ConnectionManager using httpx backend.</p>"},{"location":"api-reference/#constructor_1","title":"Constructor","text":"<p>Same parameters as <code>ConnectionManager</code>.</p>"},{"location":"api-reference/#async-http-methods","title":"Async HTTP Methods","text":"<p>All HTTP methods are async versions:</p> <pre><code>async def request(method: str, url: str, **kwargs) -&gt; httpx.Response\nasync def get(url: str, **kwargs) -&gt; httpx.Response\nasync def post(url: str, **kwargs) -&gt; httpx.Response\n# ... etc\n</code></pre>"},{"location":"api-reference/#async-batch-operations","title":"Async Batch Operations","text":"<pre><code>async def batch_request(\n    requests_data: List[Tuple[str, str, Dict[str, Any]]], \n    max_workers: int = 5,\n    return_exceptions: bool = True\n) -&gt; List[Union[httpx.Response, Exception]]\n</code></pre>"},{"location":"api-reference/#async-context-manager","title":"Async Context Manager","text":"<pre><code>async with AsyncConnectionManager() as manager:\n    response = await manager.get('https://api.example.com/data')\n</code></pre>"},{"location":"api-reference/#exception-classes","title":"Exception Classes","text":""},{"location":"api-reference/#connectionmanagererror","title":"ConnectionManagerError","text":"<p>Base exception for all connection manager errors.</p> <pre><code>class ConnectionManagerError(Exception):\n    \"\"\"Base exception for connection manager errors.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#ratelimitexceeded","title":"RateLimitExceeded","text":"<p>Raised when rate limit is exceeded.</p> <pre><code>class RateLimitExceeded(ConnectionManagerError):\n    \"\"\"Raised when rate limit is exceeded.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#circuitbreakeropen","title":"CircuitBreakerOpen","text":"<p>Raised when circuit breaker is open.</p> <pre><code>class CircuitBreakerOpen(ConnectionManagerError):\n    \"\"\"Raised when circuit breaker is open.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#maxretriesexceeded","title":"MaxRetriesExceeded","text":"<p>Raised when maximum retries are exceeded.</p> <pre><code>class MaxRetriesExceeded(ConnectionManagerError):\n    \"\"\"Raised when maximum retries are exceeded.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#plugin-system-classes","title":"Plugin System Classes","text":""},{"location":"api-reference/#requestcontext","title":"RequestContext","text":"<p>Context object passed to pre-request hooks.</p> <pre><code>class RequestContext:\n    def __init__(self, method: str, url: str, **kwargs):\n        self.method = method\n        self.url = url\n        self.kwargs = kwargs\n</code></pre> <p>Attributes: - <code>method</code>: HTTP method - <code>url</code>: Request URL - <code>kwargs</code>: Request parameters dictionary</p>"},{"location":"api-reference/#responsecontext","title":"ResponseContext","text":"<p>Context object passed to post-response hooks.</p> <pre><code>class ResponseContext:\n    def __init__(self, response, request_context: RequestContext):\n        self.response = response\n        self.request_context = request_context\n</code></pre> <p>Attributes: - <code>response</code>: Response object - <code>request_context</code>: Original request context</p>"},{"location":"api-reference/#errorcontext","title":"ErrorContext","text":"<p>Context object passed to error hooks.</p> <pre><code>class ErrorContext:\n    def __init__(self, exception: Exception, request_context: RequestContext):\n        self.exception = exception\n        self.request_context = request_context\n        self.handled = False\n        self.fallback_response = None\n</code></pre> <p>Attributes: - <code>exception</code>: The exception that occurred - <code>request_context</code>: Original request context - <code>handled</code>: Set to True to mark error as handled - <code>fallback_response</code>: Optional fallback response</p>"},{"location":"api-reference/#hooktype","title":"HookType","text":"<p>Enumeration of hook types.</p> <pre><code>class HookType(Enum):\n    PRE_REQUEST = \"pre_request\"\n    POST_RESPONSE = \"post_response\"\n    ERROR_HANDLER = \"error_handler\"\n</code></pre>"},{"location":"api-reference/#pluginmanager","title":"PluginManager","text":"<p>Manages plugin hooks.</p> <pre><code>class PluginManager:\n    def register_hook(self, hook_type: HookType, hook_func: Callable) -&gt; None\n    def unregister_hook(self, hook_type: HookType, hook_func: Callable) -&gt; None\n    def execute_pre_request_hooks(self, context: RequestContext) -&gt; None\n    def execute_post_response_hooks(self, context: ResponseContext) -&gt; None\n    def execute_error_hooks(self, context: ErrorContext) -&gt; None\n    def list_hooks(self) -&gt; Dict[str, List[str]]\n</code></pre>"},{"location":"api-reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api-reference/#safe_log_request","title":"safe_log_request()","text":"<pre><code>safe_log_request(method: str, url: str, headers: Optional[Dict] = None, payload: Optional[Any] = None) -&gt; None\n</code></pre> <p>Safely log request details without exposing sensitive information.</p>"},{"location":"api-reference/#safe_log_response","title":"safe_log_response()","text":"<pre><code>safe_log_response(response) -&gt; None\n</code></pre> <p>Safely log response details.</p>"},{"location":"api-reference/#safe_log_error","title":"safe_log_error()","text":"<pre><code>safe_log_error(exception: Exception, method: str, url: str, level: int = logging.ERROR) -&gt; None\n</code></pre> <p>Safely log error details.</p>"},{"location":"api-reference/#type-hints","title":"Type Hints","text":"<p>Common type definitions used throughout the library:</p> <pre><code>from typing import Dict, List, Optional, Union, Any, Callable, Tuple\n\nEndpointConfig = Dict[str, Any]\nRequestData = Tuple[str, str, Dict[str, Any]]\nBatchResults = List[Union[requests.Response, Exception]]\n</code></pre>"},{"location":"api-reference/#constants","title":"Constants","text":""},{"location":"api-reference/#default-values","title":"Default Values","text":"<pre><code>DEFAULT_POOL_CONNECTIONS = 10\nDEFAULT_POOL_MAXSIZE = 10\nDEFAULT_MAX_RETRIES = 3\nDEFAULT_BACKOFF_FACTOR = 0.3\nDEFAULT_RATE_LIMIT_REQUESTS = 100\nDEFAULT_RATE_LIMIT_PERIOD = 60\nDEFAULT_CIRCUIT_BREAKER_FAILURE_THRESHOLD = 5\nDEFAULT_CIRCUIT_BREAKER_RECOVERY_TIMEOUT = 60\nDEFAULT_TIMEOUT = 30\nDEFAULT_API_KEY_HEADER = \"X-API-Key\"\n</code></pre>"},{"location":"api-reference/#example-usage","title":"Example Usage","text":""},{"location":"api-reference/#basic-usage","title":"Basic Usage","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\nwith ConnectionManager() as manager:\n    response = manager.get('https://api.example.com/data')\n    print(response.json())\n</code></pre>"},{"location":"api-reference/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>manager = ConnectionManager(\n    pool_connections=20,\n    max_retries=5,\n    rate_limit_requests=200,\n    bearer_token=\"your-token\",\n    timeout=45\n)\n\nwith manager:\n    response = manager.post(\n        'https://api.example.com/data',\n        json={'key': 'value'}\n    )\n</code></pre>"},{"location":"api-reference/#async-usage","title":"Async Usage","text":"<pre><code>import asyncio\nfrom requests_connection_manager import AsyncConnectionManager\n\nasync def main():\n    async with AsyncConnectionManager() as manager:\n        response = await manager.get('https://api.example.com/data')\n        return response.json()\n\ndata = asyncio.run(main())\n</code></pre>"},{"location":"api-reference/#plugin-usage","title":"Plugin Usage","text":"<pre><code>def log_requests(request_context):\n    print(f\"Making {request_context.method} request to {request_context.url}\")\n\nmanager = ConnectionManager()\nmanager.register_pre_request_hook(log_requests)\n\nwith manager:\n    response = manager.get('https://api.example.com/data')\n</code></pre>"},{"location":"api-reference/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Basic introduction</li> <li>Configuration - Detailed configuration options</li> <li>Usage Examples - Practical examples</li> <li>Advanced Features - Advanced capabilities</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#100-2024-12-28","title":"[1.0.0] - 2024-12-28","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#core-features","title":"Core Features","text":"<ul> <li>ConnectionManager class with connection pooling, retries, rate limiting, and circuit breaker functionality</li> <li>AsyncConnectionManager class for async/await support using httpx</li> <li>Automatic retries with exponential backoff for failed requests</li> <li>Rate limiting with configurable requests per time period</li> <li>Circuit breaker pattern to handle service failures gracefully</li> <li>Connection pooling for efficient connection reuse</li> </ul>"},{"location":"changelog/#authentication-support","title":"Authentication Support","text":"<ul> <li>API key authentication with configurable header names</li> <li>Bearer token authentication for OAuth2 and similar schemes</li> <li>Basic authentication with username/password</li> <li>Per-endpoint authentication configuration</li> <li>Global and endpoint-specific authentication methods</li> </ul>"},{"location":"changelog/#advanced-configuration","title":"Advanced Configuration","text":"<ul> <li>SSL certificate verification with custom CA bundles</li> <li>Client certificates for mutual TLS authentication</li> <li>Fine-grained timeouts (separate connect and read timeouts)</li> <li>Custom SSL contexts for advanced SSL configuration</li> <li>Per-endpoint configuration for different services</li> </ul>"},{"location":"changelog/#request-features","title":"Request Features","text":"<ul> <li>Batch requests with controlled parallelism</li> <li>Thread-safe operations for multi-threaded applications</li> <li>Context manager support for automatic resource cleanup</li> <li>All HTTP methods supported (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)</li> </ul>"},{"location":"changelog/#plugin-system","title":"Plugin System","text":"<ul> <li>Extensible plugin architecture with pre-request, post-response, and error hooks</li> <li>Request/response modification capabilities</li> <li>Error handling and fallback mechanisms</li> <li>Hook registration and management</li> </ul>"},{"location":"changelog/#monitoring-and-utilities","title":"Monitoring and Utilities","text":"<ul> <li>Statistics and monitoring with get_stats() method</li> <li>Secure logging with automatic redaction of sensitive data</li> <li>Comprehensive error handling with custom exceptions</li> <li>Performance optimizations for high-throughput scenarios</li> </ul>"},{"location":"changelog/#developer-experience","title":"Developer Experience","text":"<ul> <li>Comprehensive documentation with examples</li> <li>Type hints throughout the codebase</li> <li>Full test coverage with pytest</li> <li>GitHub Actions for CI/CD</li> <li>Semantic versioning and changelog management</li> </ul>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>requests (&gt;=2.25.0) - HTTP library for Python</li> <li>urllib3 (&gt;=1.26.0) - HTTP client library</li> <li>ratelimit (&gt;=2.2.1) - Rate limiting decorator</li> <li>pybreaker (&gt;=1.2.0) - Circuit breaker implementation</li> <li>httpx (&gt;=0.28.1) - Modern async HTTP client</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete API documentation</li> <li>Usage examples for all features</li> <li>Authentication guides</li> <li>Advanced configuration tutorials</li> <li>Contributing guidelines</li> <li>Installation instructions</li> </ul>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planned-features","title":"Planned Features","text":"<ul> <li>Metrics collection and export</li> <li>Request/response caching</li> <li>Advanced load balancing</li> <li>Distributed rate limiting</li> <li>Request replay functionality</li> <li>WebSocket support</li> <li>gRPC support</li> </ul> <p>For the complete history of changes, see the GitHub releases page.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>This guide covers all configuration options available in <code>requests-connection-manager</code>.</p>"},{"location":"configuration/#basic-configuration","title":"Basic Configuration","text":""},{"location":"configuration/#default-settings","title":"Default Settings","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\n# All default values shown\nmanager = ConnectionManager(\n    pool_connections=10,                    # Connection pools to cache\n    pool_maxsize=10,                       # Max connections per pool\n    max_retries=3,                         # Retry attempts\n    backoff_factor=0.3,                    # Retry delay multiplier\n    rate_limit_requests=100,               # Requests per period\n    rate_limit_period=60,                  # Rate limit period (seconds)\n    circuit_breaker_failure_threshold=5,   # Failures before opening\n    circuit_breaker_recovery_timeout=60,   # Recovery timeout (seconds)\n    timeout=30                             # Default timeout\n)\n</code></pre>"},{"location":"configuration/#connection-pooling","title":"Connection Pooling","text":""},{"location":"configuration/#pool-size-configuration","title":"Pool Size Configuration","text":"<pre><code># For high-throughput applications\nmanager = ConnectionManager(\n    pool_connections=50,    # More pools for different hosts\n    pool_maxsize=100       # More connections per pool\n)\n\n# For resource-constrained environments\nmanager = ConnectionManager(\n    pool_connections=5,     # Fewer pools\n    pool_maxsize=10        # Fewer connections\n)\n</code></pre>"},{"location":"configuration/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Optimized for speed\nmanager = ConnectionManager(\n    pool_connections=100,\n    pool_maxsize=200,\n    max_retries=2,          # Fewer retries\n    backoff_factor=0.1      # Faster retries\n)\n</code></pre>"},{"location":"configuration/#retry-configuration","title":"Retry Configuration","text":""},{"location":"configuration/#basic-retry-settings","title":"Basic Retry Settings","text":"<pre><code>manager = ConnectionManager(\n    max_retries=5,          # Maximum attempts\n    backoff_factor=0.5      # Exponential backoff\n)\n# Retry delays: 0.5s, 1s, 2s, 4s, 8s\n</code></pre>"},{"location":"configuration/#fine-tuned-retry-strategy","title":"Fine-tuned Retry Strategy","text":"<pre><code># Conservative retries\nmanager = ConnectionManager(\n    max_retries=2,\n    backoff_factor=1.0      # Longer delays: 1s, 2s\n)\n\n# Aggressive retries\nmanager = ConnectionManager(\n    max_retries=10,\n    backoff_factor=0.1      # Quick retries: 0.1s, 0.2s, 0.4s...\n)\n</code></pre>"},{"location":"configuration/#rate-limiting","title":"Rate Limiting","text":""},{"location":"configuration/#global-rate-limiting","title":"Global Rate Limiting","text":"<pre><code>manager = ConnectionManager(\n    rate_limit_requests=100,  # 100 requests\n    rate_limit_period=60      # per minute\n)\n</code></pre>"},{"location":"configuration/#endpoint-specific-rate-limiting","title":"Endpoint-Specific Rate Limiting","text":"<pre><code>endpoint_configs = {\n    'api.github.com': {\n        'rate_limit_requests': 60,\n        'rate_limit_period': 3600  # 60 requests per hour\n    },\n    'api.twitter.com': {\n        'rate_limit_requests': 300,\n        'rate_limit_period': 900   # 300 requests per 15 minutes\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=endpoint_configs)\n</code></pre>"},{"location":"configuration/#circuit-breaker","title":"Circuit Breaker","text":""},{"location":"configuration/#basic-circuit-breaker","title":"Basic Circuit Breaker","text":"<pre><code>manager = ConnectionManager(\n    circuit_breaker_failure_threshold=5,   # Open after 5 failures\n    circuit_breaker_recovery_timeout=60    # Try recovery after 60s\n)\n</code></pre>"},{"location":"configuration/#service-specific-circuit-breakers","title":"Service-Specific Circuit Breakers","text":"<pre><code>endpoint_configs = {\n    'unstable-service.com': {\n        'circuit_breaker_failure_threshold': 3,   # More sensitive\n        'circuit_breaker_recovery_timeout': 30\n    },\n    'reliable-service.com': {\n        'circuit_breaker_failure_threshold': 10,  # More tolerant\n        'circuit_breaker_recovery_timeout': 120\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=endpoint_configs)\n</code></pre>"},{"location":"configuration/#timeout-configuration","title":"Timeout Configuration","text":""},{"location":"configuration/#simple-timeouts","title":"Simple Timeouts","text":"<pre><code># Global timeout\nmanager = ConnectionManager(timeout=30)\n\n# Request-specific timeout\nwith manager:\n    response = manager.get('https://api.example.com/data', timeout=60)\n</code></pre>"},{"location":"configuration/#fine-grained-timeouts","title":"Fine-Grained Timeouts","text":"<pre><code>manager = ConnectionManager(\n    connect_timeout=5.0,    # Connection timeout\n    read_timeout=30.0       # Read timeout\n)\n\n# Or specify per request\nwith manager:\n    response = manager.get(\n        'https://api.example.com/data',\n        timeout=(5.0, 30.0)  # (connect, read)\n    )\n</code></pre>"},{"location":"configuration/#ssl-configuration","title":"SSL Configuration","text":""},{"location":"configuration/#ssl-verification","title":"SSL Verification","text":"<pre><code># Default: verify with system CA bundle\nmanager = ConnectionManager(verify=True)\n\n# Use custom CA bundle\nmanager = ConnectionManager(verify=\"/path/to/ca-bundle.pem\")\n\n# Disable verification (not recommended for production)\nmanager = ConnectionManager(verify=False)\n</code></pre>"},{"location":"configuration/#client-certificates-mutual-tls","title":"Client Certificates (Mutual TLS)","text":"<pre><code># Single file with cert and key\nmanager = ConnectionManager(cert=\"/path/to/client.pem\")\n\n# Separate cert and key files\nmanager = ConnectionManager(\n    cert=(\"/path/to/client.crt\", \"/path/to/client.key\")\n)\n</code></pre>"},{"location":"configuration/#custom-ssl-context","title":"Custom SSL Context","text":"<pre><code>import ssl\n\n# Create custom SSL context\nssl_context = ssl.create_default_context()\nssl_context.minimum_version = ssl.TLSVersion.TLSv1_2\n\nmanager = ConnectionManager(ssl_context=ssl_context)\n</code></pre>"},{"location":"configuration/#authentication","title":"Authentication","text":""},{"location":"configuration/#api-key-authentication","title":"API Key Authentication","text":"<pre><code># Global API key\nmanager = ConnectionManager(\n    api_key=\"your-api-key\",\n    api_key_header=\"X-API-Key\"  # Custom header name\n)\n\n# Endpoint-specific API key\nendpoint_configs = {\n    'api.service1.com': {\n        'api_key': 'service1-key',\n        'api_key_header': 'X-Service1-Key'\n    }\n}\n</code></pre>"},{"location":"configuration/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<pre><code># Global Bearer token\nmanager = ConnectionManager(bearer_token=\"your-token\")\n\n# Endpoint-specific token\nendpoint_configs = {\n    'api.service.com': {\n        'bearer_token': 'service-specific-token'\n    }\n}\n</code></pre>"},{"location":"configuration/#basic-authentication","title":"Basic Authentication","text":"<pre><code># Global basic auth\nmanager = ConnectionManager(\n    basic_auth=(\"username\", \"password\")\n)\n\n# Endpoint-specific basic auth\nendpoint_configs = {\n    'secure.api.com': {\n        'basic_auth': ('user', 'pass')\n    }\n}\n</code></pre>"},{"location":"configuration/#endpoint-specific-configuration","title":"Endpoint-Specific Configuration","text":""},{"location":"configuration/#complete-endpoint-configuration","title":"Complete Endpoint Configuration","text":"<pre><code>endpoint_configs = {\n    'critical-service.com': {\n        # Connection settings\n        'timeout': 120,\n        'max_retries': 5,\n        'backoff_factor': 0.5,\n\n        # Rate limiting\n        'rate_limit_requests': 50,\n        'rate_limit_period': 60,\n\n        # Circuit breaker\n        'circuit_breaker_failure_threshold': 3,\n        'circuit_breaker_recovery_timeout': 300,\n\n        # Authentication\n        'bearer_token': 'critical-service-token',\n\n        # SSL settings\n        'verify': '/path/to/critical-service-ca.pem',\n        'cert': ('/path/to/client.crt', '/path/to/client.key')\n    },\n    'analytics-service.com': {\n        'timeout': 90,\n        'rate_limit_requests': 20,\n        'rate_limit_period': 60,\n        'max_retries': 2\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=endpoint_configs)\n</code></pre>"},{"location":"configuration/#environment-based-configuration","title":"Environment-Based Configuration","text":""},{"location":"configuration/#development-configuration","title":"Development Configuration","text":"<pre><code>import os\n\ndef create_dev_manager():\n    return ConnectionManager(\n        verify=False,                    # Skip SSL in dev\n        timeout=120,                     # Longer timeouts for debugging\n        rate_limit_requests=1000,        # No real rate limiting\n        circuit_breaker_failure_threshold=50  # More forgiving\n    )\n</code></pre>"},{"location":"configuration/#production-configuration","title":"Production Configuration","text":"<pre><code>def create_prod_manager():\n    return ConnectionManager(\n        verify=True,                     # Strict SSL\n        timeout=30,                      # Reasonable timeouts\n        max_retries=3,                   # Proper retry count\n        rate_limit_requests=100,         # Proper rate limiting\n        circuit_breaker_failure_threshold=5,\n        connect_timeout=5.0,             # Quick connection timeout\n        read_timeout=25.0                # Reasonable read timeout\n    )\n</code></pre>"},{"location":"configuration/#dynamic-configuration","title":"Dynamic Configuration","text":""},{"location":"configuration/#runtime-updates","title":"Runtime Updates","text":"<pre><code>manager = ConnectionManager()\n\n# Update authentication\nmanager.set_bearer_token(\"new-token\")\nmanager.set_api_key(\"new-key\", \"X-New-Header\")\n\n# Update SSL settings\nmanager.set_ssl_verification(\"/new/ca-bundle.pem\")\nmanager.set_client_certificate((\"/new/cert.crt\", \"/new/key.key\"))\n\n# Update timeouts\nmanager.set_timeouts(connect_timeout=3.0, read_timeout=20.0)\n\n# Add endpoint configuration\nmanager.add_endpoint_config('new-api.com', {\n    'timeout': 60,\n    'rate_limit_requests': 25\n})\n</code></pre>"},{"location":"configuration/#configuration-validation","title":"Configuration Validation","text":""},{"location":"configuration/#getting-current-configuration","title":"Getting Current Configuration","text":"<pre><code>with manager:\n    # Get comprehensive stats\n    stats = manager.get_stats()\n\n    print(f\"Circuit breaker state: {stats['circuit_breaker_state']}\")\n    print(f\"Rate limit: {stats['rate_limit_requests']}/{stats['rate_limit_period']}s\")\n    print(f\"SSL verification: {stats['ssl_verification']}\")\n    print(f\"Endpoint configs: {len(stats['endpoint_configs'])}\")\n</code></pre>"},{"location":"configuration/#best-practices","title":"Best Practices","text":""},{"location":"configuration/#production-recommendations","title":"Production Recommendations","text":"<pre><code># Recommended production configuration\nmanager = ConnectionManager(\n    # Conservative connection pooling\n    pool_connections=20,\n    pool_maxsize=50,\n\n    # Reasonable retry strategy\n    max_retries=3,\n    backoff_factor=0.5,\n\n    # Proper rate limiting\n    rate_limit_requests=100,\n    rate_limit_period=60,\n\n    # Fail-fast circuit breaker\n    circuit_breaker_failure_threshold=5,\n    circuit_breaker_recovery_timeout=60,\n\n    # Quick timeouts\n    timeout=30,\n    connect_timeout=5.0,\n    read_timeout=25.0,\n\n    # Secure defaults\n    verify=True\n)\n</code></pre>"},{"location":"configuration/#high-performance-configuration","title":"High-Performance Configuration","text":"<pre><code># For high-throughput applications\nmanager = ConnectionManager(\n    pool_connections=100,\n    pool_maxsize=200,\n    max_retries=2,\n    backoff_factor=0.1,\n    rate_limit_requests=1000,\n    timeout=15,\n    connect_timeout=2.0,\n    read_timeout=10.0\n)\n</code></pre>"},{"location":"configuration/#resource-constrained-configuration","title":"Resource-Constrained Configuration","text":"<pre><code># For limited resources\nmanager = ConnectionManager(\n    pool_connections=5,\n    pool_maxsize=10,\n    max_retries=1,\n    rate_limit_requests=20,\n    timeout=60\n)\n</code></pre>"},{"location":"configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Usage Examples - See configuration in action</li> <li>Advanced Features - Explore advanced capabilities</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"contributing/","title":"Contributing to requests-connection-manager","text":"<p>Thank you for your interest in contributing to requests-connection-manager! This document provides guidelines and information for contributors.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>Poetry for dependency management</li> <li>Git</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/requests-connection-manager.git\ncd requests-connection-manager\n</code></pre></p> </li> <li> <p>Install dependencies using Poetry:    <pre><code>poetry install\n</code></pre></p> </li> <li> <p>Install pre-commit hooks (optional but recommended):    <pre><code>poetry run pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a new branch for your feature or bug fix:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes following the coding standards below</p> </li> <li> <p>Add or update tests as necessary</p> </li> <li> <p>Update documentation if needed</p> </li> <li> <p>Update CHANGELOG.md following the Keep a Changelog format</p> </li> </ol>"},{"location":"contributing/#code-standards","title":"Code Standards","text":"<ul> <li>Code Formatting: Use <code>black</code> for code formatting</li> <li>Import Sorting: Use <code>isort</code> for import organization</li> <li>Linting: Code must pass <code>flake8</code> checks</li> <li>Type Hints: Use type hints for all public functions</li> <li>Docstrings: Follow Google-style docstrings</li> </ul> <p>Run code quality checks: <pre><code># Format code\npoetry run black requests_connection_manager/ tests/\n\n# Sort imports\npoetry run isort requests_connection_manager/ tests/\n\n# Run linting\npoetry run flake8 requests_connection_manager/ tests/\n\n# Type checking\npoetry run mypy requests_connection_manager/\n</code></pre></p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Run the test suite: <pre><code># Run all tests\npoetry run pytest\n\n# Run with coverage\npoetry run pytest --cov=requests_connection_manager\n\n# Run specific test file\npoetry run pytest tests/test_manager.py\n\n# Run with verbose output\npoetry run pytest -v\n</code></pre></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Build and serve documentation locally: <pre><code># Install documentation dependencies\npip install mkdocs mkdocs-material mkdocstrings[python]\n\n# Serve documentation\nmkdocs serve --dev-addr=0.0.0.0:5000\n\n# Build documentation\nmkdocs build\n</code></pre></p>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>Use clear, descriptive commit messages:</p> <pre><code>feat: add rate limiting configuration per endpoint\n\n- Allow different rate limits for different endpoints\n- Add endpoint_configs parameter to ConnectionManager\n- Update documentation with examples\n\nCloses #123\n</code></pre> <p>Commit message types: - <code>feat:</code> - New features - <code>fix:</code> - Bug fixes - <code>docs:</code> - Documentation changes - <code>test:</code> - Test additions or modifications - <code>refactor:</code> - Code refactoring - <code>perf:</code> - Performance improvements - <code>chore:</code> - Maintenance tasks</p>"},{"location":"contributing/#versioning","title":"Versioning","text":"<p>This project follows Semantic Versioning:</p> <ul> <li>MAJOR: Incompatible API changes</li> <li>MINOR: Backwards-compatible functionality additions</li> <li>PATCH: Backwards-compatible bug fixes</li> </ul> <p>Use the version bumping script: <pre><code>python scripts/bump_version.py patch  # or minor, major\n</code></pre></p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your code follows the style guidelines</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> <li>Update CHANGELOG.md</li> <li>Ensure all tests pass</li> <li>Create a pull request with a clear description</li> </ol>"},{"location":"contributing/#pull-request-template","title":"Pull Request Template","text":"<p>When creating a pull request, please include:</p> <ul> <li>Description: What does this PR do?</li> <li>Motivation: Why is this change needed?</li> <li>Testing: How was this tested?</li> <li>Documentation: What documentation was updated?</li> <li>Breaking Changes: Any breaking changes?</li> </ul>"},{"location":"contributing/#release-process","title":"Release Process","text":"<ol> <li>Update version using the bump script</li> <li>Update CHANGELOG.md with release notes</li> <li>Commit changes: <code>git commit -m \"Bump version to X.Y.Z\"</code></li> <li>Create tag: <code>git tag vX.Y.Z</code></li> <li>Push: <code>git push &amp;&amp; git push --tags</code></li> <li>GitHub Actions will automatically publish to PyPI</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and professional in all interactions. We're committed to providing a welcoming environment for all contributors.</p>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: Open an issue for bugs or feature requests</li> <li>Discussions: Use GitHub Discussions for questions</li> <li>Email: Contact maintainers directly for private matters</li> </ul>"},{"location":"contributing/#areas-for-contribution","title":"Areas for Contribution","text":"<p>We welcome contributions in these areas:</p>"},{"location":"contributing/#features","title":"Features","text":"<ul> <li>New authentication methods</li> <li>Additional retry strategies</li> <li>Enhanced monitoring and metrics</li> <li>Performance optimizations</li> </ul>"},{"location":"contributing/#documentation_1","title":"Documentation","text":"<ul> <li>Usage examples</li> <li>API documentation improvements</li> <li>Tutorial content</li> <li>Video guides</li> </ul>"},{"location":"contributing/#testing_1","title":"Testing","text":"<ul> <li>Additional test cases</li> <li>Performance benchmarks</li> <li>Integration tests</li> <li>Load testing</li> </ul>"},{"location":"contributing/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Performance issues</li> <li>Edge case handling</li> <li>Memory leaks</li> <li>Thread safety issues</li> </ul>"},{"location":"contributing/#development-tips","title":"Development Tips","text":""},{"location":"contributing/#running-examples","title":"Running Examples","text":"<p>Test your changes with the provided examples: <pre><code>python examples/basic_examples.py\npython examples/authentication_examples.py\npython examples/advanced_connection_examples.py\n</code></pre></p>"},{"location":"contributing/#debugging","title":"Debugging","text":"<p>Enable debug logging to troubleshoot issues: <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\nfrom requests_connection_manager import ConnectionManager\nmanager = ConnectionManager()\n</code></pre></p>"},{"location":"contributing/#performance-testing","title":"Performance Testing","text":"<p>Use the batch request examples to test performance: <pre><code>python examples/batch_request_examples.py\n</code></pre></p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to requests-connection-manager, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"contributing/#thank-you","title":"Thank You","text":"<p>Thank you for contributing to requests-connection-manager! Your efforts help make this project better for everyone.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to <code>requests-connection-manager</code>! This guide will help you get up and running quickly with enhanced HTTP connection management.</p>"},{"location":"getting-started/#what-is-requests-connection-manager","title":"What is requests-connection-manager?","text":"<p><code>requests-connection-manager</code> is a Python package that extends the popular <code>requests</code> library with advanced features:</p> <ul> <li>Connection Pooling: Efficient reuse of HTTP connections</li> <li>Automatic Retries: Smart retry logic with exponential backoff</li> <li>Rate Limiting: Prevent API abuse with built-in throttling</li> <li>Circuit Breaker: Fail-fast pattern for handling service failures</li> <li>Authentication: Support for multiple auth methods</li> <li>Async Support: Full async/await compatibility</li> <li>Plugin System: Extensible hooks for custom functionality</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>Basic familiarity with HTTP requests and the <code>requests</code> library</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install the package using pip:</p> <pre><code>pip install requests-connection-manager\n</code></pre> <p>For development installation:</p> <pre><code>git clone https://github.com/charlesgude/requests-connection-manager.git\ncd requests-connection-manager\npip install -e .\n</code></pre>"},{"location":"getting-started/#your-first-request","title":"Your First Request","text":"<p>Let's start with a simple example:</p> <pre><code>from requests_connection_manager import ConnectionManager\n\n# Create a connection manager with default settings\nwith ConnectionManager() as manager:\n    response = manager.get('https://httpbin.org/get')\n    print(f\"Status: {response.status_code}\")\n    print(f\"Response: {response.json()}\")\n</code></pre> <p>That's it! You've just made your first request with automatic connection pooling, retries, and rate limiting.</p>"},{"location":"getting-started/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/#connection-manager","title":"Connection Manager","text":"<p>The <code>ConnectionManager</code> is your main interface for making HTTP requests. It handles all the advanced features transparently.</p>"},{"location":"getting-started/#context-manager-pattern","title":"Context Manager Pattern","text":"<p>Always use the <code>with</code> statement to ensure proper resource cleanup:</p> <pre><code>with ConnectionManager() as manager:\n    # Make your requests here\n    response = manager.get('https://api.example.com/data')\n# Resources are automatically cleaned up\n</code></pre>"},{"location":"getting-started/#built-in-features","title":"Built-in Features","text":"<p>All requests automatically benefit from: - Connection pooling for better performance - Retry logic for transient failures - Rate limiting to prevent overwhelming APIs - Circuit breaker pattern for service protection</p>"},{"location":"getting-started/#configuration-overview","title":"Configuration Overview","text":"<p>You can customize the behavior during initialization:</p> <pre><code>manager = ConnectionManager(\n    pool_connections=20,      # Number of connection pools\n    max_retries=5,           # Retry attempts\n    rate_limit_requests=100, # Requests per minute\n    timeout=30               # Default timeout\n)\n</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<ul> <li>Configuration - Learn about all configuration options</li> <li>Usage Examples - See practical examples</li> <li>Advanced Features - Explore powerful features</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/#common-use-cases","title":"Common Use Cases","text":""},{"location":"getting-started/#api-integration","title":"API Integration","text":"<p>Perfect for integrating with external APIs with built-in resilience:</p> <pre><code>with ConnectionManager(\n    rate_limit_requests=60,  # Respect API limits\n    max_retries=3           # Handle transient failures\n) as manager:\n    response = manager.get('https://api.service.com/data')\n</code></pre>"},{"location":"getting-started/#microservices-communication","title":"Microservices Communication","text":"<p>Ideal for service-to-service communication:</p> <pre><code>manager = ConnectionManager(\n    circuit_breaker_failure_threshold=5,  # Fail fast\n    timeout=10                            # Quick timeouts\n)\n</code></pre>"},{"location":"getting-started/#bulk-data-processing","title":"Bulk Data Processing","text":"<p>Efficient for processing multiple requests:</p> <pre><code>requests_data = [\n    ('GET', 'https://api.example.com/item/1', {}),\n    ('GET', 'https://api.example.com/item/2', {}),\n    ('GET', 'https://api.example.com/item/3', {})\n]\n\nwith ConnectionManager() as manager:\n    results = manager.batch_request(requests_data, max_workers=5)\n</code></pre> <p>Ready to dive deeper? Check out our Usage Examples for more comprehensive scenarios!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Operating System: Windows, macOS, or Linux</li> </ul>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The easiest way to install <code>requests-connection-manager</code> is using pip:</p> <pre><code>pip install requests-connection-manager\n</code></pre>"},{"location":"installation/#install-from-source","title":"Install from Source","text":"<p>If you want to install from the source code:</p> <pre><code>git clone https://github.com/charlesgude/requests-connection-manager.git\ncd requests-connection-manager\npip install -e .\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development, install with development dependencies:</p> <pre><code>git clone https://github.com/charlesgude/requests-connection-manager.git\ncd requests-connection-manager\npip install -e \".[dev]\"\n</code></pre> <p>Or if you're using Poetry:</p> <pre><code>git clone https://github.com/charlesgude/requests-connection-manager.git\ncd requests-connection-manager\npoetry install\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The package automatically installs these dependencies:</p> <ul> <li>requests (&gt;=2.25.0) - HTTP library for Python</li> <li>urllib3 (&gt;=1.26.0) - HTTP client library</li> <li>ratelimit (&gt;=2.2.1) - Rate limiting decorator</li> <li>pybreaker (&gt;=1.2.0) - Circuit breaker implementation</li> <li>httpx (&gt;=0.28.1) - Modern async HTTP client</li> </ul>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>To verify the installation was successful:</p> <pre><code>import requests_connection_manager\nprint(requests_connection_manager.__version__)\n</code></pre> <p>You should see the version number printed without any errors.</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started with basic usage</li> <li>Basic Usage - Learn the fundamentals</li> <li>Examples - See practical examples</li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Get up and running with <code>requests-connection-manager</code> in just a few minutes!</p>"},{"location":"quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"quick-start/#simple-get-request","title":"Simple GET Request","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\n# Create a connection manager\nmanager = ConnectionManager()\n\n# Make a GET request\nresponse = manager.get('https://httpbin.org/get')\nprint(f\"Status: {response.status_code}\")\nprint(f\"Response: {response.json()}\")\n\n# Clean up\nmanager.close()\n</code></pre>"},{"location":"quick-start/#using-context-manager","title":"Using Context Manager","text":"<p>The recommended approach is to use a context manager for automatic cleanup:</p> <pre><code>from requests_connection_manager import ConnectionManager\n\nwith ConnectionManager() as manager:\n    response = manager.get('https://httpbin.org/get')\n    print(f\"Status: {response.status_code}\")\n# Automatically closed when exiting the context\n</code></pre>"},{"location":"quick-start/#configuration-example","title":"Configuration Example","text":"<p>Customize the connection manager with your preferred settings:</p> <pre><code>from requests_connection_manager import ConnectionManager\n\nmanager = ConnectionManager(\n    pool_connections=20,          # Number of connection pools\n    pool_maxsize=20,             # Max connections per pool\n    max_retries=5,               # Retry attempts\n    backoff_factor=0.5,          # Retry delay multiplier\n    rate_limit_requests=100,     # Requests per period\n    rate_limit_period=60,        # Rate limit period (seconds)\n    timeout=30                   # Default request timeout\n)\n\nwith manager:\n    # Rate limiting automatically prevents excessive requests\n    for i in range(10):\n        response = manager.get(f'https://httpbin.org/get?id={i}')\n        print(f\"Request {i}: {response.status_code}\")\n</code></pre>"},{"location":"quick-start/#http-methods","title":"HTTP Methods","text":"<p>All standard HTTP methods are supported:</p> <pre><code>with ConnectionManager() as manager:\n    # GET request\n    response = manager.get('https://httpbin.org/get')\n\n    # POST request with JSON data\n    data = {'key': 'value', 'number': 42}\n    response = manager.post('https://httpbin.org/post', json=data)\n\n    # PUT request\n    response = manager.put('https://httpbin.org/put', json=data)\n\n    # DELETE request\n    response = manager.delete('https://httpbin.org/delete')\n\n    # Custom headers\n    headers = {'Authorization': 'Bearer your-token'}\n    response = manager.get('https://httpbin.org/headers', headers=headers)\n</code></pre>"},{"location":"quick-start/#authentication","title":"Authentication","text":""},{"location":"quick-start/#api-key-authentication","title":"API Key Authentication","text":"<pre><code>manager = ConnectionManager(\n    api_key=\"your-api-key\",\n    api_key_header=\"X-API-Key\"\n)\n\nwith manager:\n    response = manager.get('https://api.example.com/data')\n    # X-API-Key header automatically added\n</code></pre>"},{"location":"quick-start/#bearer-token","title":"Bearer Token","text":"<pre><code>manager = ConnectionManager(bearer_token=\"your-bearer-token\")\n\nwith manager:\n    response = manager.get('https://api.example.com/protected')\n    # Authorization: Bearer header automatically added\n</code></pre>"},{"location":"quick-start/#error-handling","title":"Error Handling","text":"<pre><code>from requests_connection_manager import ConnectionManager\nfrom requests_connection_manager.exceptions import (\n    RateLimitExceeded,\n    CircuitBreakerOpen,\n    MaxRetriesExceeded\n)\n\nwith ConnectionManager() as manager:\n    try:\n        response = manager.get('https://api.example.com/data')\n        print(f\"Success: {response.status_code}\")\n    except RateLimitExceeded:\n        print(\"Rate limit exceeded, please wait\")\n    except CircuitBreakerOpen:\n        print(\"Service is currently unavailable\")\n    except MaxRetriesExceeded:\n        print(\"Request failed after maximum retries\")\n</code></pre>"},{"location":"quick-start/#async-usage","title":"Async Usage","text":"<p>For async applications, use <code>AsyncConnectionManager</code>:</p> <pre><code>import asyncio\nfrom requests_connection_manager import AsyncConnectionManager\n\nasync def main():\n    async with AsyncConnectionManager() as manager:\n        response = await manager.get('https://httpbin.org/get')\n        print(f\"Status: {response.status_code}\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics down, explore more advanced features:</p> <ul> <li>Authentication - Learn about all authentication methods</li> <li>Advanced Configuration - SSL, timeouts, and more</li> <li>Endpoint Configuration - Per-service configurations</li> <li>Examples - See more comprehensive examples</li> </ul>"},{"location":"usage-examples/","title":"Usage Examples","text":"<p>This page provides practical examples of using <code>requests-connection-manager</code> in real-world scenarios.</p>"},{"location":"usage-examples/#basic-usage-examples","title":"Basic Usage Examples","text":""},{"location":"usage-examples/#simple-get-request","title":"Simple GET Request","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\n# Basic GET request with automatic features\nwith ConnectionManager() as manager:\n    response = manager.get('https://httpbin.org/get')\n    print(f\"Status: {response.status_code}\")\n    print(f\"Data: {response.json()}\")\n</code></pre>"},{"location":"usage-examples/#post-request-with-json-data","title":"POST Request with JSON Data","text":"<pre><code>with ConnectionManager() as manager:\n    data = {\n        'name': 'John Doe',\n        'email': 'john@example.com',\n        'age': 30\n    }\n\n    response = manager.post(\n        'https://httpbin.org/post',\n        json=data,\n        headers={'Content-Type': 'application/json'}\n    )\n\n    print(f\"Response: {response.json()}\")\n</code></pre>"},{"location":"usage-examples/#file-upload","title":"File Upload","text":"<pre><code>with ConnectionManager() as manager:\n    files = {'file': open('document.pdf', 'rb')}\n    data = {'description': 'Important document'}\n\n    response = manager.post(\n        'https://httpbin.org/post',\n        files=files,\n        data=data\n    )\n\n    print(f\"Upload status: {response.status_code}\")\n</code></pre>"},{"location":"usage-examples/#authentication-examples","title":"Authentication Examples","text":""},{"location":"usage-examples/#api-key-authentication","title":"API Key Authentication","text":"<pre><code># Global API key\nmanager = ConnectionManager(\n    api_key=\"your-api-key-here\",\n    api_key_header=\"X-API-Key\"\n)\n\nwith manager:\n    # API key automatically added to all requests\n    response = manager.get('https://api.example.com/protected-data')\n    print(response.json())\n</code></pre>"},{"location":"usage-examples/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<pre><code># OAuth2/Bearer token\nmanager = ConnectionManager(bearer_token=\"your-oauth-token\")\n\nwith manager:\n    response = manager.get('https://api.example.com/user/profile')\n    print(f\"User data: {response.json()}\")\n</code></pre>"},{"location":"usage-examples/#basic-authentication","title":"Basic Authentication","text":"<pre><code># Username and password\nmanager = ConnectionManager(\n    basic_auth=(\"username\", \"password\")\n)\n\nwith manager:\n    response = manager.get('https://httpbin.org/basic-auth/username/password')\n    print(f\"Authenticated: {response.status_code == 200}\")\n</code></pre>"},{"location":"usage-examples/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<pre><code># Different auth for different services\nendpoint_configs = {\n    'api.github.com': {\n        'bearer_token': 'github-token'\n    },\n    'api.service.com': {\n        'api_key': 'service-key',\n        'api_key_header': 'X-Service-Key'\n    },\n    'secure.internal.com': {\n        'basic_auth': ('admin', 'secret')\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=endpoint_configs)\n\nwith manager:\n    # Each request uses appropriate authentication\n    github_response = manager.get('https://api.github.com/user')\n    service_response = manager.get('https://api.service.com/data')\n    internal_response = manager.get('https://secure.internal.com/admin')\n</code></pre>"},{"location":"usage-examples/#error-handling-examples","title":"Error Handling Examples","text":""},{"location":"usage-examples/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>from requests_connection_manager import ConnectionManager\nfrom requests_connection_manager.exceptions import (\n    RateLimitExceeded,\n    CircuitBreakerOpen,\n    MaxRetriesExceeded\n)\nimport requests\n\nwith ConnectionManager() as manager:\n    try:\n        response = manager.get('https://api.example.com/data')\n        response.raise_for_status()  # Raise exception for HTTP errors\n        data = response.json()\n\n    except RateLimitExceeded:\n        print(\"Rate limit exceeded, please wait\")\n\n    except CircuitBreakerOpen:\n        print(\"Service is currently unavailable\")\n\n    except MaxRetriesExceeded:\n        print(\"Request failed after maximum retries\")\n\n    except requests.HTTPError as e:\n        print(f\"HTTP error: {e}\")\n\n    except requests.RequestException as e:\n        print(f\"Request error: {e}\")\n</code></pre>"},{"location":"usage-examples/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>def fetch_user_data(user_id):\n    \"\"\"Fetch user data with fallback strategies.\"\"\"\n    manager = ConnectionManager(\n        max_retries=3,\n        circuit_breaker_failure_threshold=5\n    )\n\n    with manager:\n        try:\n            # Try primary API\n            response = manager.get(f'https://api.primary.com/users/{user_id}')\n            return response.json()\n\n        except CircuitBreakerOpen:\n            # Try backup API if primary is down\n            try:\n                response = manager.get(f'https://api.backup.com/users/{user_id}')\n                return response.json()\n            except Exception:\n                # Return cached data or default\n                return get_cached_user_data(user_id)\n\n        except Exception as e:\n            print(f\"Failed to fetch user data: {e}\")\n            return None\n</code></pre>"},{"location":"usage-examples/#concurrent-requests-examples","title":"Concurrent Requests Examples","text":""},{"location":"usage-examples/#batch-requests","title":"Batch Requests","text":"<pre><code># Prepare multiple requests\nrequests_data = [\n    ('GET', 'https://httpbin.org/get?id=1', {}),\n    ('GET', 'https://httpbin.org/get?id=2', {}),\n    ('GET', 'https://httpbin.org/get?id=3', {}),\n    ('POST', 'https://httpbin.org/post', {'json': {'data': 'test'}}),\n    ('GET', 'https://httpbin.org/delay/1', {'timeout': 5})\n]\n\nwith ConnectionManager() as manager:\n    # Execute all requests concurrently\n    results = manager.batch_request(\n        requests_data,\n        max_workers=3,\n        return_exceptions=True\n    )\n\n    # Process results\n    for i, result in enumerate(results):\n        if isinstance(result, Exception):\n            print(f\"Request {i} failed: {result}\")\n        else:\n            print(f\"Request {i} success: {result.status_code}\")\n</code></pre>"},{"location":"usage-examples/#data-aggregation","title":"Data Aggregation","text":"<pre><code>def fetch_user_details(user_ids):\n    \"\"\"Fetch details for multiple users concurrently.\"\"\"\n    requests_data = [\n        ('GET', f'https://api.example.com/users/{user_id}', {})\n        for user_id in user_ids\n    ]\n\n    with ConnectionManager() as manager:\n        results = manager.batch_request(\n            requests_data,\n            max_workers=10\n        )\n\n        users = []\n        for result in results:\n            if not isinstance(result, Exception):\n                users.append(result.json())\n\n        return users\n\n# Usage\nuser_ids = [1, 2, 3, 4, 5]\nusers = fetch_user_details(user_ids)\nprint(f\"Fetched {len(users)} users\")\n</code></pre>"},{"location":"usage-examples/#async-examples","title":"Async Examples","text":""},{"location":"usage-examples/#basic-async-usage","title":"Basic Async Usage","text":"<pre><code>import asyncio\nfrom requests_connection_manager import AsyncConnectionManager\n\nasync def fetch_data():\n    async with AsyncConnectionManager() as manager:\n        response = await manager.get('https://httpbin.org/get')\n        return response.json()\n\n# Run async function\ndata = asyncio.run(fetch_data())\nprint(data)\n</code></pre>"},{"location":"usage-examples/#async-batch-requests","title":"Async Batch Requests","text":"<pre><code>async def async_batch_example():\n    requests_data = [\n        ('GET', 'https://httpbin.org/get?page=1', {}),\n        ('GET', 'https://httpbin.org/get?page=2', {}),\n        ('GET', 'https://httpbin.org/get?page=3', {})\n    ]\n\n    async with AsyncConnectionManager() as manager:\n        results = await manager.batch_request(\n            requests_data,\n            max_workers=5\n        )\n\n        for i, result in enumerate(results):\n            if not isinstance(result, Exception):\n                print(f\"Page {i+1}: {result.status_code}\")\n\nasyncio.run(async_batch_example())\n</code></pre>"},{"location":"usage-examples/#api-integration-examples","title":"API Integration Examples","text":""},{"location":"usage-examples/#rest-api-client","title":"REST API Client","text":"<pre><code>class APIClient:\n    def __init__(self, base_url, api_key):\n        self.manager = ConnectionManager(\n            api_key=api_key,\n            api_key_header=\"Authorization\",\n            timeout=30,\n            max_retries=3\n        )\n        self.base_url = base_url.rstrip('/')\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.manager.close()\n\n    def get_user(self, user_id):\n        with self.manager:\n            response = self.manager.get(f'{self.base_url}/users/{user_id}')\n            response.raise_for_status()\n            return response.json()\n\n    def create_user(self, user_data):\n        with self.manager:\n            response = self.manager.post(\n                f'{self.base_url}/users',\n                json=user_data\n            )\n            response.raise_for_status()\n            return response.json()\n\n    def update_user(self, user_id, user_data):\n        with self.manager:\n            response = self.manager.put(\n                f'{self.base_url}/users/{user_id}',\n                json=user_data\n            )\n            response.raise_for_status()\n            return response.json()\n\n# Usage\nwith APIClient('https://api.example.com', 'your-api-key') as client:\n    user = client.get_user(123)\n    print(f\"User: {user['name']}\")\n</code></pre>"},{"location":"usage-examples/#microservices-communication","title":"Microservices Communication","text":"<pre><code>class ServiceRegistry:\n    def __init__(self):\n        # Configure different settings for different services\n        endpoint_configs = {\n            'user-service': {\n                'timeout': 10,\n                'rate_limit_requests': 200,\n                'circuit_breaker_failure_threshold': 5\n            },\n            'order-service': {\n                'timeout': 30,\n                'rate_limit_requests': 100,\n                'circuit_breaker_failure_threshold': 3\n            },\n            'notification-service': {\n                'timeout': 5,\n                'rate_limit_requests': 500,\n                'max_retries': 1  # Fire and forget\n            }\n        }\n\n        self.manager = ConnectionManager(\n            endpoint_configs=endpoint_configs,\n            bearer_token=self._get_service_token()\n        )\n\n    def _get_service_token(self):\n        # Get service-to-service authentication token\n        return \"service-token\"\n\n    def get_user_profile(self, user_id):\n        with self.manager:\n            response = self.manager.get(\n                f'https://user-service/api/users/{user_id}'\n            )\n            return response.json()\n\n    def create_order(self, order_data):\n        with self.manager:\n            response = self.manager.post(\n                'https://order-service/api/orders',\n                json=order_data\n            )\n            return response.json()\n\n    def send_notification(self, notification_data):\n        with self.manager:\n            try:\n                self.manager.post(\n                    'https://notification-service/api/notify',\n                    json=notification_data\n                )\n            except Exception as e:\n                # Log but don't fail the main operation\n                print(f\"Notification failed: {e}\")\n</code></pre>"},{"location":"usage-examples/#real-world-scenarios","title":"Real-World Scenarios","text":""},{"location":"usage-examples/#data-pipeline","title":"Data Pipeline","text":"<pre><code>def process_data_pipeline():\n    \"\"\"Example data processing pipeline with external API calls.\"\"\"\n\n    # Configure for data processing workload\n    manager = ConnectionManager(\n        pool_connections=20,\n        pool_maxsize=50,\n        rate_limit_requests=200,\n        rate_limit_period=60,\n        timeout=120  # Longer timeout for data processing\n    )\n\n    with manager:\n        # Step 1: Fetch source data\n        response = manager.get('https://api.data-source.com/export')\n        source_data = response.json()\n\n        # Step 2: Process data in batches\n        processed_items = []\n        batch_size = 10\n\n        for i in range(0, len(source_data['items']), batch_size):\n            batch = source_data['items'][i:i+batch_size]\n\n            # Prepare batch requests for enrichment\n            enrichment_requests = [\n                ('GET', f'https://api.enrichment.com/enhance/{item[\"id\"]}', {})\n                for item in batch\n            ]\n\n            # Execute batch enrichment\n            enrichment_results = manager.batch_request(\n                enrichment_requests,\n                max_workers=5\n            )\n\n            # Combine original data with enrichment\n            for item, enrichment in zip(batch, enrichment_results):\n                if not isinstance(enrichment, Exception):\n                    item.update(enrichment.json())\n                processed_items.append(item)\n\n        # Step 3: Save processed data\n        response = manager.post(\n            'https://api.storage.com/bulk-save',\n            json={'items': processed_items}\n        )\n\n        return response.json()\n</code></pre>"},{"location":"usage-examples/#monitoring-and-health-checks","title":"Monitoring and Health Checks","text":"<pre><code>def health_check_system():\n    \"\"\"Monitor multiple services with different requirements.\"\"\"\n\n    services = {\n        'critical-api': {\n            'url': 'https://critical-api.com/health',\n            'timeout': 5,\n            'max_retries': 1\n        },\n        'user-service': {\n            'url': 'https://user-service.com/health',\n            'timeout': 10,\n            'max_retries': 2\n        },\n        'analytics-service': {\n            'url': 'https://analytics.com/health',\n            'timeout': 30,\n            'max_retries': 1\n        }\n    }\n\n    # Configure endpoint-specific settings\n    endpoint_configs = {\n        service_name: {\n            'timeout': config['timeout'],\n            'max_retries': config['max_retries'],\n            'circuit_breaker_failure_threshold': 2\n        }\n        for service_name, config in services.items()\n    }\n\n    manager = ConnectionManager(endpoint_configs=endpoint_configs)\n\n    with manager:\n        health_status = {}\n\n        # Prepare health check requests\n        health_requests = [\n            ('GET', config['url'], {})\n            for service_name, config in services.items()\n        ]\n\n        # Execute all health checks concurrently\n        results = manager.batch_request(\n            health_requests,\n            max_workers=len(services),\n            return_exceptions=True\n        )\n\n        # Process results\n        for (service_name, _), result in zip(services.items(), results):\n            if isinstance(result, Exception):\n                health_status[service_name] = {\n                    'status': 'unhealthy',\n                    'error': str(result)\n                }\n            else:\n                health_status[service_name] = {\n                    'status': 'healthy' if result.status_code == 200 else 'degraded',\n                    'response_time': result.elapsed.total_seconds(),\n                    'status_code': result.status_code\n                }\n\n        return health_status\n\n# Run health checks\nhealth = health_check_system()\nfor service, status in health.items():\n    print(f\"{service}: {status['status']}\")\n</code></pre>"},{"location":"usage-examples/#plugin-examples","title":"Plugin Examples","text":""},{"location":"usage-examples/#custom-logging-plugin","title":"Custom Logging Plugin","text":"<pre><code>def request_logger(request_context):\n    \"\"\"Log all outgoing requests.\"\"\"\n    print(f\"Making {request_context.method} request to {request_context.url}\")\n\ndef response_logger(response_context):\n    \"\"\"Log all responses.\"\"\"\n    response = response_context.response\n    duration = getattr(response, 'elapsed', None)\n    duration_ms = duration.total_seconds() * 1000 if duration else 'unknown'\n\n    print(f\"Response: {response.status_code} in {duration_ms:.1f}ms\")\n\n# Register hooks\nmanager = ConnectionManager()\nmanager.register_pre_request_hook(request_logger)\nmanager.register_post_response_hook(response_logger)\n\nwith manager:\n    response = manager.get('https://httpbin.org/get')\n    # Logs: Making GET request to https://httpbin.org/get\n    # Logs: Response: 200 in 245.3ms\n</code></pre>"},{"location":"usage-examples/#metrics-collection-plugin","title":"Metrics Collection Plugin","text":"<pre><code>import time\nfrom collections import defaultdict\n\nclass MetricsCollector:\n    def __init__(self):\n        self.request_counts = defaultdict(int)\n        self.response_times = defaultdict(list)\n        self.error_counts = defaultdict(int)\n\n    def pre_request_hook(self, request_context):\n        request_context.start_time = time.time()\n\n    def post_response_hook(self, response_context):\n        url = response_context.request_context.url\n        duration = time.time() - response_context.request_context.start_time\n\n        self.request_counts[url] += 1\n        self.response_times[url].append(duration)\n\n    def error_hook(self, error_context):\n        url = error_context.request_context.url\n        self.error_counts[url] += 1\n\n    def get_metrics(self):\n        metrics = {}\n        for url in self.request_counts:\n            avg_time = sum(self.response_times[url]) / len(self.response_times[url])\n            metrics[url] = {\n                'request_count': self.request_counts[url],\n                'avg_response_time': avg_time,\n                'error_count': self.error_counts[url]\n            }\n        return metrics\n\n# Usage\nmetrics = MetricsCollector()\nmanager = ConnectionManager()\n\nmanager.register_pre_request_hook(metrics.pre_request_hook)\nmanager.register_post_response_hook(metrics.post_response_hook)\nmanager.register_error_hook(metrics.error_hook)\n\nwith manager:\n    # Make some requests\n    for i in range(5):\n        manager.get(f'https://httpbin.org/get?id={i}')\n\n# Get metrics\nprint(metrics.get_metrics())\n</code></pre>"},{"location":"usage-examples/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Features - Explore powerful features</li> <li>API Reference - Complete API documentation</li> <li>Configuration - Detailed configuration options</li> </ul>"},{"location":"usage/advanced/","title":"Advanced Configuration","text":"<p>This guide covers advanced configuration options for SSL, timeouts, connection settings, and more.</p>"},{"location":"usage/advanced/#ssl-and-certificate-configuration","title":"SSL and Certificate Configuration","text":""},{"location":"usage/advanced/#ssl-verification","title":"SSL Verification","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\n# Disable SSL verification (not recommended for production)\nmanager = ConnectionManager(verify=False)\n\n# Use custom CA bundle\nmanager = ConnectionManager(verify=\"/path/to/ca-bundle.pem\")\n\n# Use system default CA bundle (default)\nmanager = ConnectionManager(verify=True)\n</code></pre>"},{"location":"usage/advanced/#client-certificates-mutual-tls","title":"Client Certificates (Mutual TLS)","text":"<pre><code># Single file containing both cert and key\nmanager = ConnectionManager(cert=\"/path/to/client.pem\")\n\n# Separate cert and key files\nmanager = ConnectionManager(cert=(\"/path/to/client.crt\", \"/path/to/client.key\"))\n\n# Update after initialization\nmanager = ConnectionManager()\nmanager.set_client_certificate((\"/path/to/cert.crt\", \"/path/to/key.key\"))\n</code></pre>"},{"location":"usage/advanced/#custom-ssl-context","title":"Custom SSL Context","text":"<pre><code>import ssl\nfrom requests_connection_manager import ConnectionManager\n\n# Create custom SSL context\nssl_context = ssl.create_default_context()\nssl_context.minimum_version = ssl.TLSVersion.TLSv1_2\nssl_context.check_hostname = False\n\nmanager = ConnectionManager(ssl_context=ssl_context)\n\n# Update after initialization\nmanager.set_ssl_context(ssl_context)\n</code></pre>"},{"location":"usage/advanced/#timeout-configuration","title":"Timeout Configuration","text":""},{"location":"usage/advanced/#basic-timeouts","title":"Basic Timeouts","text":"<pre><code># Global timeout for all requests\nmanager = ConnectionManager(timeout=30)\n\n# Request-specific timeout\nwith manager:\n    response = manager.get('https://api.example.com/data', timeout=60)\n</code></pre>"},{"location":"usage/advanced/#fine-grained-timeouts","title":"Fine-Grained Timeouts","text":"<pre><code># Separate connection and read timeouts\nmanager = ConnectionManager(\n    connect_timeout=5.0,  # 5 seconds to establish connection\n    read_timeout=30.0     # 30 seconds to read response\n)\n\n# Update timeouts after initialization\nmanager.set_timeouts(connect_timeout=3.0, read_timeout=25.0)\n\n# Tuple format for request-specific timeouts\nwith manager:\n    response = manager.get(\n        'https://api.example.com/data',\n        timeout=(5.0, 30.0)  # (connect, read)\n    )\n</code></pre>"},{"location":"usage/advanced/#connection-pool-configuration","title":"Connection Pool Configuration","text":""},{"location":"usage/advanced/#pool-settings","title":"Pool Settings","text":"<pre><code>manager = ConnectionManager(\n    pool_connections=20,    # Number of connection pools to cache\n    pool_maxsize=50,       # Maximum connections per pool\n    max_retries=5          # Retry attempts per connection\n)\n</code></pre>"},{"location":"usage/advanced/#advanced-pool-configuration","title":"Advanced Pool Configuration","text":"<pre><code># For high-throughput applications\nmanager = ConnectionManager(\n    pool_connections=100,   # More pools for different hosts\n    pool_maxsize=100,      # More connections per pool\n    max_retries=3,\n    backoff_factor=0.1     # Faster retries\n)\n\n# For resource-constrained environments\nmanager = ConnectionManager(\n    pool_connections=5,     # Fewer pools\n    pool_maxsize=10,       # Fewer connections\n    max_retries=2\n)\n</code></pre>"},{"location":"usage/advanced/#retry-configuration","title":"Retry Configuration","text":""},{"location":"usage/advanced/#retry-strategy","title":"Retry Strategy","text":"<pre><code>manager = ConnectionManager(\n    max_retries=5,          # Maximum retry attempts\n    backoff_factor=0.5      # Exponential backoff multiplier\n)\n\n# Retry delays: 0.5s, 1s, 2s, 4s, 8s\n</code></pre>"},{"location":"usage/advanced/#custom-retry-logic","title":"Custom Retry Logic","text":"<pre><code>from urllib3.util.retry import Retry\nfrom requests.adapters import HTTPAdapter\n\n# Create custom retry strategy\nretry_strategy = Retry(\n    total=3,\n    backoff_factor=1.0,\n    status_forcelist=[429, 500, 502, 503, 504],\n    method_whitelist=[\"HEAD\", \"GET\", \"OPTIONS\", \"POST\"]\n)\n\n# Apply to manager's session (advanced usage)\nmanager = ConnectionManager()\nadapter = HTTPAdapter(max_retries=retry_strategy)\nmanager.session.mount(\"https://\", adapter)\nmanager.session.mount(\"http://\", adapter)\n</code></pre>"},{"location":"usage/advanced/#rate-limiting-configuration","title":"Rate Limiting Configuration","text":""},{"location":"usage/advanced/#global-rate-limiting","title":"Global Rate Limiting","text":"<pre><code>manager = ConnectionManager(\n    rate_limit_requests=100,  # Requests allowed\n    rate_limit_period=60      # Time period in seconds\n)\n</code></pre>"},{"location":"usage/advanced/#per-endpoint-rate-limiting","title":"Per-Endpoint Rate Limiting","text":"<pre><code>endpoint_configs = {\n    'api.github.com': {\n        'rate_limit_requests': 60,\n        'rate_limit_period': 3600  # 60 requests per hour\n    },\n    'api.twitter.com': {\n        'rate_limit_requests': 300,\n        'rate_limit_period': 900   # 300 requests per 15 minutes\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=endpoint_configs)\n</code></pre>"},{"location":"usage/advanced/#circuit-breaker-configuration","title":"Circuit Breaker Configuration","text":""},{"location":"usage/advanced/#basic-circuit-breaker","title":"Basic Circuit Breaker","text":"<pre><code>manager = ConnectionManager(\n    circuit_breaker_failure_threshold=5,   # Open after 5 failures\n    circuit_breaker_recovery_timeout=60    # Try to recover after 60 seconds\n)\n</code></pre>"},{"location":"usage/advanced/#per-endpoint-circuit-breakers","title":"Per-Endpoint Circuit Breakers","text":"<pre><code>endpoint_configs = {\n    'unreliable-service.com': {\n        'circuit_breaker_failure_threshold': 3,\n        'circuit_breaker_recovery_timeout': 30\n    },\n    'stable-service.com': {\n        'circuit_breaker_failure_threshold': 10,\n        'circuit_breaker_recovery_timeout': 120\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=endpoint_configs)\n</code></pre>"},{"location":"usage/advanced/#comprehensive-configuration-example","title":"Comprehensive Configuration Example","text":"<pre><code>import ssl\nfrom requests_connection_manager import ConnectionManager\n\n# Create custom SSL context\nssl_context = ssl.create_default_context()\nssl_context.minimum_version = ssl.TLSVersion.TLSv1_2\n\n# Endpoint-specific configurations\nendpoint_configs = {\n    'secure-bank-api.com': {\n        'timeout': 120,\n        'rate_limit_requests': 10,\n        'rate_limit_period': 60,\n        'circuit_breaker_failure_threshold': 3,\n        'circuit_breaker_recovery_timeout': 300,\n        'bearer_token': 'bank-api-token'\n    },\n    'partner-api.example.com': {\n        'timeout': 45,\n        'rate_limit_requests': 50,\n        'rate_limit_period': 60,\n        'api_key': 'partner-api-key',\n        'api_key_header': 'X-Partner-Key'\n    },\n    'internal-service.company.com': {\n        'timeout': 30,\n        'rate_limit_requests': 200,\n        'rate_limit_period': 60,\n        'verify': '/path/to/internal-ca.pem',\n        'cert': ('/path/to/client.crt', '/path/to/client.key')\n    }\n}\n\n# Create manager with comprehensive configuration\nmanager = ConnectionManager(\n    # Connection pooling\n    pool_connections=50,\n    pool_maxsize=100,\n\n    # Retry configuration\n    max_retries=3,\n    backoff_factor=0.5,\n\n    # Default rate limiting\n    rate_limit_requests=100,\n    rate_limit_period=60,\n\n    # Default circuit breaker\n    circuit_breaker_failure_threshold=5,\n    circuit_breaker_recovery_timeout=60,\n\n    # Default timeout\n    timeout=30,\n\n    # SSL configuration\n    verify=True,\n    cert=None,\n    connect_timeout=5.0,\n    read_timeout=30.0,\n    ssl_context=ssl_context,\n\n    # Global authentication\n    bearer_token=\"global-default-token\",\n\n    # Endpoint-specific configurations\n    endpoint_configs=endpoint_configs\n)\n\nwith manager:\n    # Bank API - uses secure config with long timeout\n    bank_response = manager.get('https://secure-bank-api.com/account/balance')\n\n    # Partner API - uses partner-specific API key\n    partner_response = manager.get('https://partner-api.example.com/data')\n\n    # Internal service - uses mutual TLS\n    internal_response = manager.get('https://internal-service.company.com/metrics')\n\n    # Other services use global defaults\n    public_response = manager.get('https://api.publicservice.com/data')\n</code></pre>"},{"location":"usage/advanced/#dynamic-configuration-updates","title":"Dynamic Configuration Updates","text":""},{"location":"usage/advanced/#runtime-configuration-changes","title":"Runtime Configuration Changes","text":"<pre><code>manager = ConnectionManager()\n\n# Update authentication\nmanager.set_bearer_token(\"new-token\")\n\n# Update SSL settings\nmanager.set_ssl_verification(\"/new/path/to/ca-bundle.pem\")\nmanager.set_client_certificate((\"/new/cert.crt\", \"/new/key.key\"))\n\n# Update timeouts\nmanager.set_timeouts(connect_timeout=2.0, read_timeout=15.0)\n\n# Add new endpoint configuration\nmanager.add_endpoint_config('new-api.com', {\n    'timeout': 60,\n    'rate_limit_requests': 25,\n    'api_key': 'new-api-key'\n})\n\n# Remove endpoint configuration\nmanager.remove_endpoint_config('old-api.com')\n</code></pre>"},{"location":"usage/advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"usage/advanced/#high-throughput-configuration","title":"High-Throughput Configuration","text":"<pre><code># Optimized for high request volume\nmanager = ConnectionManager(\n    pool_connections=100,      # Many pools for different hosts\n    pool_maxsize=200,         # Large pool size\n    max_retries=2,            # Fewer retries for speed\n    backoff_factor=0.1,       # Quick retries\n    rate_limit_requests=1000, # High rate limit\n    rate_limit_period=60,\n    circuit_breaker_failure_threshold=10,\n    timeout=15,               # Shorter timeout\n    connect_timeout=2.0,      # Quick connection timeout\n    read_timeout=10.0         # Reasonable read timeout\n)\n</code></pre>"},{"location":"usage/advanced/#resource-constrained-configuration","title":"Resource-Constrained Configuration","text":"<pre><code># Optimized for low resource usage\nmanager = ConnectionManager(\n    pool_connections=5,        # Few pools\n    pool_maxsize=10,          # Small pool size\n    max_retries=1,            # Minimal retries\n    rate_limit_requests=20,   # Conservative rate limit\n    rate_limit_period=60,\n    circuit_breaker_failure_threshold=3,\n    timeout=60,               # Longer timeout tolerance\n    connect_timeout=10.0,\n    read_timeout=30.0\n)\n</code></pre>"},{"location":"usage/advanced/#monitoring-and-statistics","title":"Monitoring and Statistics","text":""},{"location":"usage/advanced/#getting-performance-statistics","title":"Getting Performance Statistics","text":"<pre><code>with manager:\n    # Make some requests\n    for i in range(10):\n        response = manager.get(f'https://api.example.com/item/{i}')\n\n    # Get detailed statistics\n    stats = manager.get_stats()\n\n    print(f\"Circuit breaker state: {stats['circuit_breaker_state']}\")\n    print(f\"Failure count: {stats['circuit_breaker_failure_count']}\")\n    print(f\"Rate limit: {stats['rate_limit_requests']}/{stats['rate_limit_period']}s\")\n    print(f\"SSL verification: {stats['ssl_verification']}\")\n    print(f\"Client cert configured: {stats['client_certificate_configured']}\")\n    print(f\"Connect timeout: {stats['connect_timeout']}s\")\n    print(f\"Read timeout: {stats['read_timeout']}s\")\n    print(f\"Registered hooks: {stats['registered_hooks']}\")\n    print(f\"Endpoint configs: {len(stats['endpoint_configs'])}\")\n</code></pre>"},{"location":"usage/advanced/#environment-specific-configurations","title":"Environment-Specific Configurations","text":""},{"location":"usage/advanced/#development-environment","title":"Development Environment","text":"<pre><code># Development configuration\ndev_manager = ConnectionManager(\n    verify=False,             # Skip SSL verification for local testing\n    timeout=120,              # Longer timeouts for debugging\n    max_retries=1,           # Fewer retries to fail fast\n    rate_limit_requests=1000, # No real rate limiting\n    circuit_breaker_failure_threshold=50  # More forgiving\n)\n</code></pre>"},{"location":"usage/advanced/#production-environment","title":"Production Environment","text":"<pre><code># Production configuration\nprod_manager = ConnectionManager(\n    verify=True,              # Strict SSL verification\n    timeout=30,               # Reasonable timeouts\n    max_retries=3,           # Sensible retry count\n    rate_limit_requests=100, # Proper rate limiting\n    rate_limit_period=60,\n    circuit_breaker_failure_threshold=5,\n    circuit_breaker_recovery_timeout=60,\n    connect_timeout=5.0,     # Quick connection timeout\n    read_timeout=25.0        # Reasonable read timeout\n)\n</code></pre>"},{"location":"usage/advanced/#next-steps","title":"Next Steps","text":"<ul> <li>Endpoint Configuration - Per-service configurations</li> <li>Batch Requests - Concurrent request processing</li> <li>Examples - Advanced usage examples</li> </ul>"},{"location":"usage/authentication/","title":"Authentication","text":"<p><code>requests-connection-manager</code> supports multiple authentication methods that can be applied globally or per-endpoint.</p>"},{"location":"usage/authentication/#api-key-authentication","title":"API Key Authentication","text":""},{"location":"usage/authentication/#global-api-key","title":"Global API Key","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\n# Default header (X-API-Key)\nmanager = ConnectionManager(api_key=\"your-api-key\")\n\n# Custom header\nmanager = ConnectionManager(\n    api_key=\"your-api-key\",\n    api_key_header=\"Authorization\"\n)\n\nwith manager:\n    response = manager.get('https://api.example.com/data')\n    # X-API-Key: your-api-key header automatically added\n</code></pre>"},{"location":"usage/authentication/#setting-api-key-after-initialization","title":"Setting API Key After Initialization","text":"<pre><code>manager = ConnectionManager()\nmanager.set_api_key(\"new-api-key\", \"X-Custom-Key\")\n\nwith manager:\n    response = manager.get('https://api.example.com/data')\n</code></pre>"},{"location":"usage/authentication/#bearer-token-authentication","title":"Bearer Token Authentication","text":""},{"location":"usage/authentication/#global-bearer-token","title":"Global Bearer Token","text":"<pre><code>manager = ConnectionManager(bearer_token=\"your-bearer-token\")\n\nwith manager:\n    response = manager.get('https://api.example.com/protected')\n    # Authorization: Bearer your-bearer-token header automatically added\n</code></pre>"},{"location":"usage/authentication/#setting-bearer-token-after-initialization","title":"Setting Bearer Token After Initialization","text":"<pre><code>manager = ConnectionManager()\nmanager.set_bearer_token(\"new-bearer-token\")\n\nwith manager:\n    response = manager.get('https://api.example.com/data')\n</code></pre>"},{"location":"usage/authentication/#oauth2-token-authentication","title":"OAuth2 Token Authentication","text":"<p>OAuth2 tokens are handled the same way as Bearer tokens:</p> <pre><code># Global OAuth2 token\nmanager = ConnectionManager(oauth2_token=\"your-oauth2-token\")\n\n# Set after initialization\nmanager = ConnectionManager()\nmanager.set_oauth2_token(\"new-oauth2-token\")\n\nwith manager:\n    response = manager.get('https://api.example.com/oauth-protected')\n    # Authorization: Bearer your-oauth2-token header automatically added\n</code></pre>"},{"location":"usage/authentication/#basic-authentication","title":"Basic Authentication","text":""},{"location":"usage/authentication/#global-basic-auth","title":"Global Basic Auth","text":"<pre><code>manager = ConnectionManager(basic_auth=(\"username\", \"password\"))\n\nwith manager:\n    response = manager.get('https://api.example.com/basic-protected')\n    # Authorization: Basic &lt;base64-encoded-credentials&gt; header automatically added\n</code></pre>"},{"location":"usage/authentication/#setting-basic-auth-after-initialization","title":"Setting Basic Auth After Initialization","text":"<pre><code>manager = ConnectionManager()\nmanager.set_basic_auth(\"username\", \"password\")\n\nwith manager:\n    response = manager.get('https://api.example.com/data')\n</code></pre>"},{"location":"usage/authentication/#per-endpoint-authentication","title":"Per-Endpoint Authentication","text":"<p>Configure different authentication for different services:</p>"},{"location":"usage/authentication/#setting-up-endpoint-specific-auth","title":"Setting Up Endpoint-Specific Auth","text":"<pre><code>manager = ConnectionManager()\n\n# API key for service 1\nmanager.set_endpoint_auth(\n    'api.service1.com', \n    'api_key', \n    api_key='service1-key',\n    header_name='X-Service1-Key'\n)\n\n# Bearer token for service 2\nmanager.set_endpoint_auth(\n    'api.service2.com',\n    'bearer',\n    token='service2-bearer-token'\n)\n\n# Basic auth for service 3\nmanager.set_endpoint_auth(\n    'api.service3.com',\n    'basic',\n    username='user',\n    password='pass'\n)\n\nwith manager:\n    # Each request uses the appropriate authentication\n    response1 = manager.get('https://api.service1.com/data')  # Uses API key\n    response2 = manager.get('https://api.service2.com/data')  # Uses Bearer token\n    response3 = manager.get('https://api.service3.com/data')  # Uses Basic auth\n</code></pre>"},{"location":"usage/authentication/#endpoint-configuration-with-authentication","title":"Endpoint Configuration with Authentication","text":"<pre><code>endpoint_configs = {\n    'api.github.com': {\n        'bearer_token': 'github-token',\n        'timeout': 30,\n        'rate_limit_requests': 60,\n        'rate_limit_period': 3600  # GitHub allows 60 requests per hour for auth'd users\n    },\n    'api.twitter.com': {\n        'bearer_token': 'twitter-token',\n        'timeout': 15,\n        'rate_limit_requests': 300,\n        'rate_limit_period': 900  # Twitter allows 300 requests per 15 minutes\n    },\n    'internal-api.company.com': {\n        'api_key': 'internal-api-key',\n        'api_key_header': 'X-Internal-Key',\n        'timeout': 60\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=endpoint_configs)\n\nwith manager:\n    # GitHub API request\n    response = manager.get('https://api.github.com/user')\n\n    # Twitter API request  \n    response = manager.get('https://api.twitter.com/2/tweets/search/recent')\n\n    # Internal API request\n    response = manager.get('https://internal-api.company.com/data')\n</code></pre>"},{"location":"usage/authentication/#manual-authentication","title":"Manual Authentication","text":"<p>For custom authentication schemes, you can manually add headers:</p> <pre><code>with ConnectionManager() as manager:\n    # Custom authentication header\n    headers = {\n        'X-Custom-Auth': 'custom-auth-token',\n        'X-Client-Version': '2.0'\n    }\n    response = manager.get('https://api.example.com/data', headers=headers)\n\n    # JWT token\n    jwt_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n    headers = {'Authorization': f'JWT {jwt_token}'}\n    response = manager.get('https://api.example.com/jwt-protected', headers=headers)\n</code></pre>"},{"location":"usage/authentication/#authentication-priority","title":"Authentication Priority","text":"<p>When multiple authentication methods are configured, the priority is:</p> <ol> <li>Request-level headers (highest priority)</li> <li>Endpoint-specific authentication</li> <li>Global authentication (lowest priority)</li> </ol> <pre><code>manager = ConnectionManager(\n    bearer_token=\"global-token\"  # Global auth\n)\n\n# Endpoint-specific auth overrides global\nmanager.set_endpoint_auth('api.service.com', 'api_key', api_key='endpoint-key')\n\nwith manager:\n    # Uses endpoint-specific API key\n    response1 = manager.get('https://api.service.com/data')\n\n    # Request-level auth overrides everything\n    headers = {'Authorization': 'Bearer request-level-token'}\n    response2 = manager.get('https://api.service.com/data', headers=headers)\n\n    # Uses global bearer token\n    response3 = manager.get('https://other-api.com/data')\n</code></pre>"},{"location":"usage/authentication/#clearing-authentication","title":"Clearing Authentication","text":""},{"location":"usage/authentication/#clear-global-authentication","title":"Clear Global Authentication","text":"<pre><code>manager = ConnectionManager(bearer_token=\"some-token\")\nmanager.clear_auth()  # Removes global authentication\n\nwith manager:\n    # No authentication headers added\n    response = manager.get('https://api.example.com/data')\n</code></pre>"},{"location":"usage/authentication/#clear-endpoint-specific-authentication","title":"Clear Endpoint-Specific Authentication","text":"<pre><code>manager = ConnectionManager()\nmanager.set_endpoint_auth('api.service.com', 'bearer', token='service-token')\n\n# Clear auth for specific endpoint\nmanager.clear_auth('api.service.com')\n\nwith manager:\n    # No authentication for this endpoint\n    response = manager.get('https://api.service.com/data')\n</code></pre>"},{"location":"usage/authentication/#authentication-with-async","title":"Authentication with Async","text":"<p>All authentication methods work the same with <code>AsyncConnectionManager</code>:</p> <pre><code>import asyncio\nfrom requests_connection_manager import AsyncConnectionManager\n\nasync def main():\n    manager = AsyncConnectionManager(\n        bearer_token=\"async-bearer-token\"\n    )\n\n    async with manager:\n        response = await manager.get('https://api.example.com/async-data')\n        print(f\"Status: {response.status_code}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/authentication/#real-world-examples","title":"Real-World Examples","text":""},{"location":"usage/authentication/#github-api","title":"GitHub API","text":"<pre><code>manager = ConnectionManager(\n    bearer_token=\"ghp_your_github_token\",\n    rate_limit_requests=60,\n    rate_limit_period=3600  # GitHub rate limit\n)\n\nwith manager:\n    # Get user info\n    response = manager.get('https://api.github.com/user')\n    user = response.json()\n    print(f\"Hello, {user['name']}\")\n\n    # Get repositories\n    response = manager.get('https://api.github.com/user/repos')\n    repos = response.json()\n    print(f\"You have {len(repos)} repositories\")\n</code></pre>"},{"location":"usage/authentication/#multiple-apis-with-different-auth","title":"Multiple APIs with Different Auth","text":"<pre><code>manager = ConnectionManager()\n\n# Set up authentication for different services\nconfigs = {\n    'api.github.com': {\n        'bearer_token': 'github_token',\n        'rate_limit_requests': 60,\n        'rate_limit_period': 3600\n    },\n    'api.openai.com': {\n        'bearer_token': 'openai_api_key',\n        'rate_limit_requests': 20,\n        'rate_limit_period': 60\n    },\n    'internal.company.com': {\n        'api_key': 'internal_key',\n        'api_key_header': 'X-Company-Key'\n    }\n}\n\nmanager = ConnectionManager(endpoint_configs=configs)\n\nwith manager:\n    # GitHub API\n    github_response = manager.get('https://api.github.com/user')\n\n    # OpenAI API\n    openai_response = manager.post(\n        'https://api.openai.com/v1/chat/completions',\n        json={\n            'model': 'gpt-3.5-turbo',\n            'messages': [{'role': 'user', 'content': 'Hello!'}]\n        }\n    )\n\n    # Internal API\n    internal_response = manager.get('https://internal.company.com/data')\n</code></pre>"},{"location":"usage/authentication/#security-best-practices","title":"Security Best Practices","text":""},{"location":"usage/authentication/#environment-variables","title":"Environment Variables","text":"<p>Store sensitive credentials in environment variables:</p> <pre><code>import os\nfrom requests_connection_manager import ConnectionManager\n\nmanager = ConnectionManager(\n    api_key=os.getenv('API_KEY'),\n    bearer_token=os.getenv('BEARER_TOKEN')\n)\n</code></pre>"},{"location":"usage/authentication/#credential-rotation","title":"Credential Rotation","text":"<p>Update credentials without recreating the manager:</p> <pre><code>manager = ConnectionManager()\n\ndef update_credentials():\n    new_token = fetch_new_token()  # Your token refresh logic\n    manager.set_bearer_token(new_token)\n\n# Periodically update credentials\nupdate_credentials()\n</code></pre>"},{"location":"usage/authentication/#secure-logging","title":"Secure Logging","text":"<p>The library automatically redacts sensitive information from logs:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\nmanager = ConnectionManager(api_key=\"secret-key\")\n\nwith manager:\n    # API key will be shown as [REDACTED] in logs\n    response = manager.get('https://api.example.com/data')\n</code></pre>"},{"location":"usage/authentication/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Configuration - SSL, timeouts, and custom settings</li> <li>Endpoint Configuration - Per-service configurations</li> <li>Examples - More authentication examples</li> </ul>"},{"location":"usage/basic/","title":"Basic Usage","text":"<p>This guide covers the fundamental usage patterns of <code>requests-connection-manager</code>.</p>"},{"location":"usage/basic/#creating-a-connection-manager","title":"Creating a Connection Manager","text":""},{"location":"usage/basic/#default-configuration","title":"Default Configuration","text":"<pre><code>from requests_connection_manager import ConnectionManager\n\n# Create with default settings\nmanager = ConnectionManager()\n</code></pre>"},{"location":"usage/basic/#custom-configuration","title":"Custom Configuration","text":"<pre><code>manager = ConnectionManager(\n    pool_connections=20,          # Number of connection pools\n    pool_maxsize=20,             # Max connections per pool\n    max_retries=5,               # Retry attempts\n    backoff_factor=0.5,          # Retry delay multiplier\n    rate_limit_requests=100,     # Requests per period\n    rate_limit_period=60,        # Rate limit period (seconds)\n    circuit_breaker_failure_threshold=10,  # Failures before opening circuit\n    circuit_breaker_recovery_timeout=30,   # Recovery timeout (seconds)\n    timeout=30                   # Default request timeout\n)\n</code></pre>"},{"location":"usage/basic/#http-methods","title":"HTTP Methods","text":""},{"location":"usage/basic/#get-requests","title":"GET Requests","text":"<pre><code>with ConnectionManager() as manager:\n    # Simple GET\n    response = manager.get('https://httpbin.org/get')\n\n    # GET with query parameters\n    params = {'key1': 'value1', 'key2': 'value2'}\n    response = manager.get('https://httpbin.org/get', params=params)\n\n    # GET with custom headers\n    headers = {'User-Agent': 'MyApp/1.0'}\n    response = manager.get('https://httpbin.org/get', headers=headers)\n</code></pre>"},{"location":"usage/basic/#post-requests","title":"POST Requests","text":"<pre><code>with ConnectionManager() as manager:\n    # POST with JSON data\n    data = {'name': 'John', 'age': 30}\n    response = manager.post('https://httpbin.org/post', json=data)\n\n    # POST with form data\n    form_data = {'username': 'john', 'password': 'secret'}\n    response = manager.post('https://httpbin.org/post', data=form_data)\n\n    # POST with files\n    files = {'file': open('document.pdf', 'rb')}\n    response = manager.post('https://httpbin.org/post', files=files)\n</code></pre>"},{"location":"usage/basic/#other-http-methods","title":"Other HTTP Methods","text":"<pre><code>with ConnectionManager() as manager:\n    # PUT request\n    data = {'id': 1, 'name': 'Updated Name'}\n    response = manager.put('https://httpbin.org/put', json=data)\n\n    # PATCH request\n    patch_data = {'name': 'New Name'}\n    response = manager.patch('https://httpbin.org/patch', json=patch_data)\n\n    # DELETE request\n    response = manager.delete('https://httpbin.org/delete')\n\n    # HEAD request\n    response = manager.head('https://httpbin.org/get')\n\n    # OPTIONS request\n    response = manager.options('https://httpbin.org/get')\n</code></pre>"},{"location":"usage/basic/#working-with-responses","title":"Working with Responses","text":"<pre><code>with ConnectionManager() as manager:\n    response = manager.get('https://httpbin.org/json')\n\n    # Status code\n    print(f\"Status: {response.status_code}\")\n\n    # Headers\n    print(f\"Content-Type: {response.headers['content-type']}\")\n\n    # JSON response\n    if response.headers['content-type'] == 'application/json':\n        data = response.json()\n        print(f\"Data: {data}\")\n\n    # Text response\n    print(f\"Text: {response.text}\")\n\n    # Raw bytes\n    print(f\"Content length: {len(response.content)}\")\n</code></pre>"},{"location":"usage/basic/#request-configuration","title":"Request Configuration","text":""},{"location":"usage/basic/#timeouts","title":"Timeouts","text":"<pre><code>with ConnectionManager() as manager:\n    # Request-specific timeout\n    response = manager.get('https://httpbin.org/delay/5', timeout=10)\n\n    # Fine-grained timeouts (connect, read)\n    response = manager.get(\n        'https://httpbin.org/get',\n        timeout=(5.0, 30.0)  # 5s connect, 30s read\n    )\n</code></pre>"},{"location":"usage/basic/#custom-headers","title":"Custom Headers","text":"<pre><code>with ConnectionManager() as manager:\n    headers = {\n        'User-Agent': 'MyApp/1.0',\n        'Accept': 'application/json',\n        'X-Custom-Header': 'custom-value'\n    }\n    response = manager.get('https://httpbin.org/headers', headers=headers)\n</code></pre>"},{"location":"usage/basic/#cookies","title":"Cookies","text":"<pre><code>with ConnectionManager() as manager:\n    # Send cookies\n    cookies = {'session_id': 'abc123', 'user_pref': 'dark_mode'}\n    response = manager.get('https://httpbin.org/cookies', cookies=cookies)\n\n    # Cookies are automatically handled in the session\n    response = manager.get('https://httpbin.org/cookies/set/session/value')\n    response = manager.get('https://httpbin.org/cookies')  # Includes previous cookies\n</code></pre>"},{"location":"usage/basic/#context-manager-usage","title":"Context Manager Usage","text":"<p>Always use the context manager for proper resource cleanup:</p> <pre><code># \u2705 Recommended - automatic cleanup\nwith ConnectionManager() as manager:\n    response = manager.get('https://httpbin.org/get')\n    print(response.status_code)\n# Session automatically closed\n\n# \u274c Not recommended - manual cleanup required\nmanager = ConnectionManager()\ntry:\n    response = manager.get('https://httpbin.org/get')\n    print(response.status_code)\nfinally:\n    manager.close()  # Must remember to close\n</code></pre>"},{"location":"usage/basic/#built-in-features","title":"Built-in Features","text":""},{"location":"usage/basic/#automatic-retries","title":"Automatic Retries","text":"<p>Retries are automatically handled for transient failures:</p> <pre><code>with ConnectionManager(max_retries=3, backoff_factor=0.5) as manager:\n    # Automatically retries on 5xx errors, timeouts, connection errors\n    response = manager.get('https://unreliable-service.com/api')\n</code></pre>"},{"location":"usage/basic/#rate-limiting","title":"Rate Limiting","text":"<p>Rate limiting prevents overwhelming APIs:</p> <pre><code>with ConnectionManager(rate_limit_requests=10, rate_limit_period=60) as manager:\n    # Maximum 10 requests per minute\n    for i in range(20):\n        response = manager.get(f'https://api.example.com/item/{i}')\n        # Automatically throttled after 10 requests\n</code></pre>"},{"location":"usage/basic/#circuit-breaker","title":"Circuit Breaker","text":"<p>Circuit breaker protects against failing services:</p> <pre><code>with ConnectionManager(\n    circuit_breaker_failure_threshold=5,\n    circuit_breaker_recovery_timeout=30\n) as manager:\n    # After 5 failures, circuit opens for 30 seconds\n    for i in range(10):\n        try:\n            response = manager.get('https://failing-service.com/api')\n        except CircuitBreakerOpen:\n            print(\"Circuit breaker is open, service unavailable\")\n            break\n</code></pre>"},{"location":"usage/basic/#error-handling","title":"Error Handling","text":"<pre><code>from requests_connection_manager.exceptions import (\n    ConnectionManagerError,\n    RateLimitExceeded,\n    CircuitBreakerOpen,\n    MaxRetriesExceeded\n)\nimport requests\n\nwith ConnectionManager() as manager:\n    try:\n        response = manager.get('https://api.example.com/data')\n        response.raise_for_status()  # Raises HTTPError for bad status codes\n\n    except RateLimitExceeded:\n        print(\"Rate limit exceeded\")\n    except CircuitBreakerOpen:\n        print(\"Circuit breaker is open\")\n    except MaxRetriesExceeded:\n        print(\"Max retries exceeded\")\n    except requests.HTTPError as e:\n        print(f\"HTTP error: {e}\")\n    except requests.RequestException as e:\n        print(f\"Request error: {e}\")\n    except ConnectionManagerError as e:\n        print(f\"Connection manager error: {e}\")\n</code></pre>"},{"location":"usage/basic/#thread-safety","title":"Thread Safety","text":"<p><code>ConnectionManager</code> is thread-safe and can be used across multiple threads:</p> <pre><code>import threading\nfrom requests_connection_manager import ConnectionManager\n\n# Shared manager across threads\nmanager = ConnectionManager()\n\ndef worker(worker_id):\n    for i in range(5):\n        response = manager.get(f'https://httpbin.org/get?worker={worker_id}&amp;req={i}')\n        print(f\"Worker {worker_id}, Request {i}: {response.status_code}\")\n\n# Create multiple threads\nthreads = []\nfor i in range(3):\n    thread = threading.Thread(target=worker, args=(i,))\n    threads.append(thread)\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()\n\nmanager.close()\n</code></pre>"},{"location":"usage/basic/#statistics-and-monitoring","title":"Statistics and Monitoring","text":"<p>Get insights into your connection manager's performance:</p> <pre><code>with ConnectionManager() as manager:\n    # Make some requests\n    for i in range(5):\n        response = manager.get(f'https://httpbin.org/get?req={i}')\n\n    # Get statistics\n    stats = manager.get_stats()\n    print(f\"Circuit breaker state: {stats['circuit_breaker_state']}\")\n    print(f\"Failure count: {stats['circuit_breaker_failure_count']}\")\n    print(f\"Rate limit: {stats['rate_limit_requests']}/{stats['rate_limit_period']}s\")\n    print(f\"Timeout: {stats['timeout']}s\")\n</code></pre>"},{"location":"usage/basic/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication - Learn about authentication methods</li> <li>Advanced Configuration - SSL, timeouts, and custom settings</li> <li>Endpoint Configuration - Per-service configurations</li> <li>Examples - See more comprehensive examples</li> </ul>"}]}